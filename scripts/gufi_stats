#!/usr/bin/env @PYTHON_INTERPRETER@
# This file is part of GUFI, which is part of MarFS, which is released
# under the BSD license.
#
#
# Copyright (c) 2017, Los Alamos National Security (LANS), LLC
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# From Los Alamos National Security, LLC:
# LA-CC-15-039
#
# Copyright (c) 2017, Los Alamos National Security, LLC All rights reserved.
# Copyright 2017. Los Alamos National Security, LLC. This software was produced
# under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National
# Laboratory (LANL), which is operated by Los Alamos National Security, LLC for
# the U.S. Department of Energy. The U.S. Government has rights to use,
# reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR LOS
# ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR
# ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is
# modified to produce derivative works, such modified software should be
# clearly marked, so as not to confuse it with the version available from
# LANL.
#
# THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.



from collections import OrderedDict
import argparse
import os
import subprocess
import sys

import gufi_common
import gufi_config

# Examples are outputs generated by running gufi_stats
# on the index of the tree generated by test/generatetree

# allowed keywords for sorting output (if applicable)
ASCENDING  = 'ASC'
DESCENDING = 'DESC'
ORDER = {'ASC'   : ASCENDING,
         'DESC'  : DESCENDING,
         'least' : ASCENDING,
         'most'  : DESCENDING}

def build_create(name, columns):
    return 'CREATE TABLE {0}({1})'.format(name, ', '.join(columns))

def build_where(args, root_uid=0, root_gid=0): # pylint: disable=unused-argument
    where = []

    # if not ((os.geteuid() == root_uid) or (os.getegid() == root_gid)):
    #     where  += ['(uid == {0})'.format(os.getuid())]

    if args.uid is not None:
        where += ['uid == \'{0}\''.format(args.uid)]

    return where

def depth(_config, args, where):
    '''
    get the depths of the provided directories relative to the root directory

    using --recursive/-r here will search for all directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT']),

        '-S', 'INSERT INTO {0} {1} '.format(args.inmemory_name,
                                            gufi_common.build_query(['rpath(sname, sroll)'],
                                                                    [gufi_common.VRSUMMARY],
                                                                    where,
                                                                    None,
                                                                    None,
                                                                    args.num_results,
                                                                    None)),

        '-J', 'INSERT INTO {0} {1} '.format(args.aggregate_name,
                                            gufi_common.build_query(['*'],
                                                                    [args.inmemory_name],
                                                                    None,
                                                                    None,
                                                                    None,
                                                                    None,
                                                                    None)),

        '-K', build_create(args.aggregate_name, ['name TEXT']),

        '-G', gufi_common.build_query((['CASE length(name) WHEN 0 THEN \'.\' ELSE name END'] if args.recursive else []) +
                                      ['CASE length(name) WHEN 0 THEN 0 ELSE length(name) - length(replace(name, \'/\', \'\')) END'],
                                      [args.aggregate_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '0',
                    '-z', '0']

    return queries

def filesize(_config, args, where):
    '''
    get the size the files in the immediate directory

    using --recursive here will get the size taken up by all of files
    in all subdirectories, without adding them
    '''

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT', 'size INT64']),

        '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['rpath(sname, sroll)',
                                                                    'CAST(TOTAL(size) as INT64)'],
                                                                   [gufi_common.VRPENTRIES],
                                                                   where + ['type == \'f\''],
                                                                   None,
                                                                   None,
                                                                   args.num_results,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['name', 'size'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   ['name ' + ORDER[args.order]] if args.order else None,
                                                                   args.num_results,
                                                                   None)),

        '-K', build_create(args.aggregate_name, ['name TEXT', 'size INT64']),

        '-G', gufi_common.build_query((['CASE length(name) WHEN 0 THEN \'.\' ELSE name END'] if args.recursive else []) +
                                      ['size'],
                                      [args.aggregate_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '0',
                    '-z', '0']

    return queries

def entries_count(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get the number of <type>s in the immediate directory

    using --recursive here will get the number of <type> in all subdirectories, without adding them
    '''

    queries = [
        '-E', gufi_common.build_query((['rpath({0}.name, {0}.rollupscore)'.format(gufi_common.SUMMARY)] if args.recursive else []) +
                                      ['COUNT({0}.inode)'.format(gufi_common.PENTRIES)],
                                      ['{0} LEFT JOIN {1} ON (({0}.inode == {1}.pinode) AND {1}.type == \'{2}\')'.format(gufi_common.SUMMARY, gufi_common.PENTRIES, type)],
                                      where,
                                      ['{0}.inode'.format(gufi_common.SUMMARY)],
                                      None,
                                      None,
                                      None)
    ]

    if not args.recursive:
        queries += ['-y', '0',
                    '-z', '0']

    return queries

def filecount(config, args, where):
    return entries_count(config, args, where, 'f')

def linkcount(config, args, where):
    return entries_count(config, args, where, 'l')

def extensions(_config, args, where):
    queries = [
        '-I', build_create(args.inmemory_name, ['ext TEXT', 'count INTEGER']),
        '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['REPLACE(name, RTRIM(name, REPLACE(name, \'.\', \'\')), \'\') AS ext', 'COUNT(inode)'],
                                                                   [gufi_common.VRPENTRIES],
                                                                   where,
                                                                   ['ext'],
                                                                   None,
                                                                   None,
                                                                   None)),
        '-K', build_create(args.aggregate_name, ['ext TEXT', 'count INTEGER']),
        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['ext', 'SUM(count)'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   ['ext'],
                                                                   None,
                                                                   None,
                                                                   None)),
        '-G', gufi_common.build_query(['ext', 'SUM(count)'],
                                      [args.aggregate_name],
                                      None,
                                      ['ext'],
                                      None,
                                      None,
                                      None),
    ]

    if args.recursive is False:
        queries += ['-z', '0']

    return queries

def total_filesize(_config, args, where):
    '''
    get the total size taken up by the entire directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    queries = []
    if args.cumulative:
        queries = [
            '-I', build_create(args.inmemory_name,
                               ['id INTEGER PRIMARY KEY',
                                'size INT64']),

            '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                               gufi_common.build_query(['NULL', 'totsize'],
                                                                       [gufi_common.VRSUMMARY],
                                                                       where,
                                                                       None,
                                                                       None,
                                                                       None,
                                                                       None)),

            '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                               gufi_common.build_query(['NULL', 'size'],
                                                                       [args.inmemory_name],
                                                                       None,
                                                                       None,
                                                                       None,
                                                                       None,
                                                                       None)),

            '-K', build_create(args.aggregate_name, ['id INTEGER PRIMARY KEY', 'size INT64']),

            '-G', gufi_common.build_query(['SUM(size)'],
                                          [args.aggregate_name],
                                          None,
                                          None,
                                          None,
                                          None,
                                          None),
        ]

    else:
        group_by = ['uid']
        order_by = ['uid {0}' .format(ORDER[args.order]),
                    'size {0}'.format(ORDER[args.order])]

        queries = [
            '-I', build_create(args.inmemory_name,
                               ['id INTEGER PRIMARY KEY',
                                'uid INT64',
                                'size INT64']),

            '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                               gufi_common.build_query(['NULL', 'uid', 'SUM(size)'],
                                                                       [gufi_common.VRPENTRIES],
                                                                       where + ['type == \'f\''],
                                                                       group_by,
                                                                       order_by,
                                                                       args.num_results,
                                                                       None)),

            '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                               gufi_common.build_query(['NULL', 'uid', 'size'],
                                                                       [args.inmemory_name],
                                                                       None,
                                                                       None,
                                                                       order_by,
                                                                       args.num_results,
                                                                       None)),

            '-K', build_create(args.aggregate_name,
                               ['id INTEGER PRIMARY KEY',
                                'uid INT64',
                                'size INT64']),

            '-G', gufi_common.build_query(['uidtouser(uid)', 'SUM(size)'],
                                          [args.aggregate_name],
                                          None,
                                          group_by,
                                          order_by,
                                          args.num_results,
                                          None),
        ]

    return queries

def total_entries_count(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get the total number of <type>s under the directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    group_by = None if args.cumulative else ['uid']

    E_group_by = ['pinode']    # pylint: disable=invalid-name
    if group_by is not None:
        E_group_by += group_by # pylint: disable=invalid-name

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['id INTEGER PRIMARY KEY', 'uid INT64',
                            'pinode INT64', 'count INT64']),

        '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['NULL', 'uid', 'pinode',
                                                                    'COUNT(inode) AS count'],
                                                                   [gufi_common.VRPENTRIES],
                                                                   where + ['type == \'{0}\''.format(type)],
                                                                   E_group_by,
                                                                   ['count {0}'.format(ORDER[args.order]),
                                                                    'uid {0}'.format(ORDER[args.order])],
                                                                   args.num_results,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['NULL', 'uid',
                                                                    'pinode', 'count'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   ['count {0}'.format(ORDER[args.order]),
                                                                    'uid {0}'.format(ORDER[args.order])],
                                                                   args.num_results,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['id INTEGER PRIMARY KEY', 'uid INT64',
                            'pinode INT64', 'count INT64']),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid)']) + ['SUM(count) AS count'],
                                      [args.aggregate_name],
                                      None,
                                      group_by,
                                      ['count {0}'.format(ORDER[args.order]),
                                       'uid {0}'.format(ORDER[args.order])],
                                      args.num_results,
                                      None),
    ]

    return queries

def total_filecount(config, args, where):
    return total_entries_count(config, args, where, 'f')

def total_linkcount(config, args, where):
    return total_entries_count(config, args, where, 'l')

def dircount(_config, args, where):
    '''
    get the number of subdirectories in the immediate directory

    using --recursive here will get the number of directoriess in all subdirectories, without adding them

    ############################################
    # This is wrong when running as a non-root #
    # user. Without root, the other databases  #
    # can't be accessed.                       #
    ############################################
    '''

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['path TEXT', 'inode INT64', 'pinode INT64', 'level INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['rpath(sname, sroll)', 'inode', 'pinode', 'level()'],
                                                                   [gufi_common.VRSUMMARY],
                                                                   ([] if args.recursive else ['isroot == 1']) + where,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['path', 'inode', 'pinode', 'level'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['path TEXT', 'inode INT64', 'pinode INT64', 'level INT64']),

        '-G', gufi_common.build_query((['CASE length(path) WHEN 0 THEN \'.\' ELSE path END as print_path'] if args.recursive else []) +
                                      ['(SELECT COUNT(*) FROM {0} AS nested WHERE nested.pinode == {0}.inode)'.format(args.aggregate_name)],
                                      [args.aggregate_name],
                                      None if args.recursive else ['level == 0'],
                                      None,
                                      ['print_path ASC'] if args.recursive else None,
                                      None),
    ]

    if not args.recursive:
        queries += [
            '-y', '0',
            '-z', '2']

    return queries

def total_dircount(_config, args, where):
    '''
    get the total number of directories under the directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['id INTEGER PRIMARY KEY', 'name TEXT', 'uid INT64', 'count INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['NULL', 'name', 'uid', '1 as count'],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where +
                                                                   [] if args.cumulative else [gufi_common.ROLLUP_SUMMARY_WHERE],
                                                                   group_by,
                                                                   ['count {0}'.format(ORDER[args.order]),
                                                                    'uid {0}'.format(ORDER[args.order])],
                                                                   args.num_results,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['NULL', 'name', 'uid', 'count'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   ['count {0}'.format(ORDER[args.order]),
                                                                    'uid {0}'.format(ORDER[args.order])],
                                                                   args.num_results,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['id INTEGER PRIMARY KEY', 'name TEXT', 'uid INT64', 'count INT64']),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid)']) +
                                      ['SUM(count) ' + ('' if args.cumulative else '+ 1') + ' AS count'],
                                      [args.aggregate_name],
                                      None,
                                      group_by,
                                      ['count {0}'.format(ORDER[args.order]),
                                       'uid {0}'.format(ORDER[args.order])],
                                      args.num_results,
                                      None),
    ]

    return queries

def leaf_dirs(_config, args, where):
    '''
    get the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['name TEXT']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['rpath(sname, sroll)'],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where + ['nlink == 2'],
                                                                   None,
                                                                   None,
                                                                   args.num_results,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['name'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['name TEXT']),

        '-G', gufi_common.build_query(['CASE length(name) WHEN 0 THEN \'.\' ELSE name END'],
                                      [args.aggregate_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '1',
                    '-z', '2']

    return queries

def leaf_depth(_config, args, where):
    '''
    get the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['name TEXT', 'level INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['rpath(sname, sroll)', '0'],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where + ['nlink == 2'],
                                                                   None,
                                                                   None,
                                                                   args.num_results,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['name',
                                                                    '(length(name) - length(replace(name, \'/\', \'\')))'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['name TEXT', 'level INT64']),

        '-G', gufi_common.build_query(['name', 'level'],
                                      [args.aggregate_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '1',
                    '-z', '2']

    return queries

def leaf(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get number of <type>s in the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['name TEXT', 'count INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['rpath(sname, sroll)', '(SELECT COUNT(*) FROM entries WHERE type == \'{0}\')'.format(type)],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where + ['nlink == 2'],
                                                                   None,
                                                                   None,
                                                                   args.num_results,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['name', 'count'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['name TEXT', 'count INT64']),

        '-G', gufi_common.build_query(['name', 'count'],
                                      [args.aggregate_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '1',
                    '-z', '2']

    return queries

def leaf_files(config, args, where):
    return leaf(config, args, where, 'f')

def leaf_links(config, args, where):
    return leaf(config, args, where, 'l')

def total_leaf(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get total number of <type>s in the leaf directories under this directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['uid INT64', 'count INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['uid', '(SELECT COUNT(*) FROM entries WHERE type== \'{0}\') AS count'.format(type)],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where + ['nlink == 2'],
                                                                   group_by,
                                                                   ['uid {0}'.format(ORDER[args.order]),
                                                                    'count {0}'.format(ORDER[args.order])],
                                                                   args.num_results,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['uid', 'SUM(count) AS count'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   group_by,
                                                                   ['uid {0}'.format(ORDER[args.order]),
                                                                    'count {0}'.format(ORDER[args.order])],
                                                                   args.num_results,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['uid INT64', 'count INT64']),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid)']) + ['SUM(count) AS count'],
                                      [args.aggregate_name],
                                      None,
                                      group_by,
                                      ['uid {0}'.format(ORDER[args.order]),
                                       'count {0}'.format(ORDER[args.order])],
                                      args.num_results,
                                      None),
    ]

    return queries

def total_leaf_files(config, args, where):
    return total_leaf(config, args, where, 'f')

def total_leaf_links(config, args, where):
    return total_leaf(config, args, where, 'l')

def average_leaf(_config, args, where, col):
    '''
    get average number of leaf <col> under the provided directory
    '''

    queries = [
        '-I', build_create(args.inmemory_name, ['val INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query([col],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where + ['nlink == 2'],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['val'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name, ['val INT64']),

        '-G', gufi_common.build_query(['AVG(val)'],
                                      [args.aggregate_name],
                                      None,
                                      None,
                                      None,
                                      None,
                                      None)
    ]

    return queries

def average_leaf_files(config, args, where):
    return average_leaf(config, args, where, 'totfiles')

def average_leaf_links(config, args, where):
    return average_leaf(config, args, where, 'totlinks')

def average_leaf_size(config, args, where):
    return average_leaf(config, args, where, 'totsize')

def median_leaf(_config, args, where, col):
    '''
    get median number of leaf files under the provided directory
    '''

    queries = [
        '-I', build_create(args.inmemory_name, ['count INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query([col],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where + ['nlink == 2'],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['count'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name, ['count INT64']),

        # Adapter from answer by CL
        # https://stackoverflow.com/a/15766121
        '-G', '''SELECT AVG(count)
                 FROM (SELECT count
                       FROM {0}
                       ORDER BY count
                       LIMIT 2 - (SELECT COUNT(*) FROM {0}) % 2    -- odd 1, even 2
                                  OFFSET (SELECT (COUNT(*) - 1) / 2
                                          FROM {0})
                      )'''.format(args.aggregate_name)
    ]

    return queries

def median_leaf_files(_config, args, where):
    return median_leaf(_config, args, where, 'totfiles')

def median_leaf_links(_config, args, where):
    return median_leaf(_config, args, where, 'totlinks')

def median_leaf_size(_config, args, where):
    return median_leaf(_config, args, where, 'totsize')

def per_level(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get counts of how many <type>s are in each level of the tree, by uid

    --cumulative combines the results into one set of distributions
    '''

    group_by = ['level'] + ([] if args.cumulative else ['uid'])
    order_by = None if args.cumulative else ['level {0}'.format(ORDER[args.order]),
                                             'uid {0}'.format(ORDER[args.order])]

    uid = [] if args.cumulative else ['uid']
    count = '1' if type == 'd' else '(SELECT COUNT(*) FROM entries WHERE type == \'{0}\')'.format(type)

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['id INT PRIMARY KEY'] + ([] if args.cumulative else ['uid INT64']) +
                           ['level INT64', 'count INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['NULL'] + uid + ['level()', count],
                                                                   [gufi_common.VRSUMMARY],
                                                                   where,
                                                                   ['uid'],
                                                                   None,
                                                                   None,
                                                                   None)),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['NULL'] + uid + ['level', 'SUM(count)'],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   group_by,
                                                                   order_by,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['id INT PRIMARY KEY'] +
                           ([] if args.cumulative else ['uid INT64']) +
                           ['level INT64', 'count INT64']),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid)']) + ['level', 'SUM(count)'],
                                      [args.aggregate_name],
                                      ['count != 0'],
                                      group_by,
                                      order_by,
                                      args.num_results,
                                      None),

    ]

    return queries

def files_per_level(config, args, where):
    return per_level(config, args, where, 'f')

def links_per_level(config, args, where):
    return per_level(config, args, where, 'l')

def dirs_per_level(config, args, where):
    return per_level(config, args, where, 'd')

def duplicate_names(_config, args, where):
    columns = ['name', 'type', 'inode', 'mode', 'size']

    queries = [
        '-I', build_create(args.inmemory_name,
                           ['id INTEGER PRIMARY KEY', 'path TEXT', 'name TEXT',
                            'type TEXT', 'inode INT64', 'mode INT64', 'size INT64']),

        '-S', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['NULL', 'rpath(sname, sroll)'] +
                                                                   columns,
                                                                   [gufi_common.VRSUMMARY],
                                                                   where,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(['NULL', 'rpath(sname, sroll)'] +
                                                                   columns,
                                                                   [gufi_common.VRPENTRIES],
                                                                   where,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name,
                           ['id INTEGER PRIMARY KEY', 'path TEXT', 'name TEXT',
                            'type TEXT', 'inode INT64', 'mode INT64', 'size INT64']),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(['NULL', 'path'] +
                                                                   columns,
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-G', 'SELECT lhs.name, lhs.path FROM {0} AS lhs INNER JOIN (SELECT DISTINCT name, type, size FROM {1} GROUP BY name, type, size HAVING COUNT(*) > 1) AS rhs ON ((lhs.name == rhs.name) AND (lhs.type == rhs.type) AND (lhs.size == rhs.size)) ORDER BY lhs.name'.format(args.aggregate_name, args.aggregate_name) + ('LIMIT {0}'.format(args.num_results) if args.num_results else '')

    ]

    queries += ['-a']

    return queries

def uidgid_size(args, uidgid, where):
    '''
    Sort files by size, grouped by uid or gid.

    Links are not included because they change size depending on
    filesystem.

    This function always recurses down the entire input path, but is
    neither recursive or cumulative because it creates partitions on
    the resulting data instead of processing each row of data
    independently or aggregating the data.
    '''

    columns = [uidgid, 'size', 'name']

    if args.num_results:
        where += ['rownum <= {0}'.format(args.num_results)]

    def partition(table):
        return gufi_common.build_query(columns +
                                       ['row_number() OVER (PARTITION BY {0} ORDER BY size {1}) AS rownum'.format(uidgid, args.order)],
                                       [table],
                                       None,
                                       None,
                                       None,
                                       None,
                                       None)

    queries = [
        '-I', build_create(args.inmemory_name, ['{0} INTEGER'.format(uidgid), 'size INTEGER', 'name TEXT']),

        '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query([uidgid, 'size', 'fullpath'],
                                                                   ['({0})'.format(gufi_common.build_query([uidgid, 'size',
                                                                                                            'rpath(sname, sroll) || \'/\' || name AS fullpath',
                                                                                                            'row_number() OVER (PARTITION BY {0} ORDER BY size {1}) AS rownum'.format(uidgid, args.order)],
                                                                                                           [gufi_common.VRPENTRIES],
                                                                                                           ['type == \'f\''],
                                                                                                           None,
                                                                                                           None,
                                                                                                           None,
                                                                                                           None))],
                                                                   where,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-K', build_create(args.aggregate_name, ['{0} INTEGER'.format(uidgid), 'size INTEGER', 'name TEXT']),

        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(columns,
                                                                   ['({0})'.format(partition(args.inmemory_name))],
                                                                   where,
                                                                   None,
                                                                   None,
                                                                   None,
                                                                   None)),

        '-G', gufi_common.build_query(columns,
                                      ['({0})'.format(partition(args.aggregate_name))],
                                      where,
                                      None,
                                      None,
                                      None,
                                      None),
    ]

    return queries

def uid_size(_config, args, where):
    return uidgid_size(args, 'uid', where)

def gid_size(_config, args, where):
    return uidgid_size(args, 'gid', where)

def size_bins(args, base, type): # pylint: disable=redefined-builtin
    '''
    Gets histogram of sizes
    bins are [b^n, b^(n+1))

    Requires SQLite 3.35.0

    default returns bins for 1 directory
    with --recursive, groups results by pinode
    with --cumulative, sums all results
    '''

    exponent = 'exponent'

    if type in ['f', 'l']:
        table = gufi_common.VRPENTRIES
        field = 'size'
    elif type == 'd':
        table = gufi_common.VRSUMMARY
        field = 'totfiles'

    pinode_col = 'pinode'
    pinode_create = ['{0} INTEGER'.format(pinode_col)] if args.recursive else []
    pinode = [pinode_col] if args.recursive else []

    queries = [
        '-I', build_create(args.inmemory_name, pinode_create + ['{0} INTEGER'.format(exponent)]),
        '-E', 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                           gufi_common.build_query(pinode + ['CASE WHEN {0} == 0 THEN -1 ELSE CAST(FLOOR(LOG({1}, {0})) AS INTEGER) END'.format(field,base)],
                                                                   [table],
                                                                   ['type == \'{0}\''.format(type)],
                                                                   None, # cannot GROUP BY here because value would be aggregate
                                                                   None,
                                                                   None,
                                                                   None)),
        '-K', build_create(args.aggregate_name, pinode_create + ['{0} INTEGER'.format(exponent), 'count INTEGER']),
        '-J', 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                           gufi_common.build_query(pinode + [exponent, 'COUNT({0})'.format(exponent)],
                                                                   [args.inmemory_name],
                                                                   None,
                                                                   pinode + [exponent],
                                                                   None,
                                                                   None,
                                                                   None)),
        '-G', gufi_common.build_query(pinode + ["CASE WHEN {1} == -1 THEN '[0,1)' ELSE '[' || CAST(pow({0}, {1}) AS INTEGER) || ',' || CAST(pow({0}, {1}+1) AS INTEGER) || ')' END".format(base, exponent), 'SUM(count)'],
                                      [args.aggregate_name],
                                      None,
                                      pinode + [exponent],
                                      (['{0} {1}'.format(pinode_col, ORDER[args.order])] if args.recursive else []) +
                                      ['{0} {1}'.format(exponent, ORDER[args.order])],
                                      None,
                                      None),
    ]

    if not args.recursive and not args.cumulative:
        queries += ['-z', '0']

    return queries

def filesize_log2_bins(_config, args, _where):
    return size_bins(args, 2, 'f')

def filesize_log1024_bins(_config, args, _where):
    return size_bins(args, 1024, 'f')

def dirfilecount_log2_bins(_config, args, _where):
    return size_bins(args, 2, 'd')

def dirfilecount_log1024_bins(_config, args, _where):
    return size_bins(args, 1024, 'd')

# mapping of desired statistics to functions

# normally only computes for current directory
# use --recursive to recurse down tree
RECURSIVE = [
    ['depth',                     depth],
    ['filesize',                  filesize],
    ['filecount',                 filecount],
    ['linkcount',                 linkcount],
    ['dircount',                  dircount],
    ['leaf-dirs',                 leaf_dirs],
    ['leaf-depth',                leaf_depth],
    ['leaf-files',                leaf_files],
    ['leaf-links',                leaf_links],
    ['extensions',                extensions],
]

# normally computes statistics by uid
# use --cumulative to combine
CUMULATIVE = [
    ['total-filesize',            total_filesize],
    ['total-filecount',           total_filecount],
    ['total-linkcount',           total_linkcount],
    ['total-dircount',            total_dircount],
    ['total-leaf-files',          total_leaf_files],
    ['total-leaf-links',          total_leaf_links],
    ['files-per-level',           files_per_level],
    ['links-per-level',           links_per_level],
    ['dirs-per-level',            dirs_per_level],
]

BOTH = [
    ['filesize-log2-bins',        filesize_log2_bins],
    ['filesize-log1024-bins',     filesize_log1024_bins],
    ['dirfilecount-log2-bins',    dirfilecount_log2_bins],
    ['dirfilecount-log1024-bins', dirfilecount_log1024_bins],
]

# does not use either
OTHERS = [
    ['average-leaf-files',        average_leaf_files],
    ['average-leaf-links',        average_leaf_links],
    ['average-leaf-size',         average_leaf_size], # file size only
    ['median-leaf-files',         median_leaf_files],
    ['median-leaf-links',         median_leaf_links],
    ['median-leaf-size',          median_leaf_size],  # file size only
    ['duplicate-names',           duplicate_names],
    ['uid-size',                  uid_size],
    ['gid-size',                  gid_size],
]

# argv[0] should be the command name
def run(argv, config_path):
    stats = OrderedDict(RECURSIVE + CUMULATIVE + BOTH + OTHERS)

    # find and parse the configuration file first
    config = gufi_config.Server(config_path)

    # parse the arguments
    parser = argparse.ArgumentParser('gufi_stats', description='GUFI statistics', add_help=False)

    # override help to not use -h
    parser.add_argument('--help',
                        action='help',
                        help='show this help message and exit')
    parser.add_argument('--version', '-v',
                        action='version',
                        version=os.path.basename(os.path.realpath(__file__)) + ' @GUFI_VERSION@')
    exclusive = parser.add_mutually_exclusive_group()
    exclusive.add_argument('--recursive', '-r',
                           action='store_true',
                           help='run command recursively ({0})'.format(', '.join([key for key, _ in RECURSIVE + BOTH])))
    exclusive.add_argument('--cumulative', '-c',
                           action='store_true',
                           help='return cumulative values ({0})'.format(', '.join([key for key, _ in CUMULATIVE + BOTH])))
    parser.add_argument('--order',
                        metavar='order',
                        choices=ORDER.keys(),
                        default=ASCENDING,
                        help='sort output (if applicable)')
    parser.add_argument('--num-results',
                        metavar='n',
                        type=gufi_common.get_non_negative,
                        help='first n results')
    parser.add_argument('--uid', '--user',
                        metavar='u',
                        type=gufi_common.get_uid,
                        help='restrict to user')
    parser.add_argument('stat',
                        choices=stats.keys(),
                        help='statistic to get')
    parser.add_argument('path',
                        type=str,
                        nargs='?',
                        default='')

    gufi_common.add_common_flags(parser)

    args = parser.parse_args(argv[1:])

    # check args
    if args.recursive and (args.stat in [key for key, _ in CUMULATIVE]):
        sys.stderr.write('--recursive/-r has no effect on "{0}" statistic\n'.format(args.stat))
    if args.cumulative and (args.stat in [key for key, _ in RECURSIVE]):
        sys.stderr.write('--cumulative/-c has no effect on "{0}" statistic\n'.format(args.stat))
    if (args.recursive or args.cumulative) and (args.stat in [key for key, _ in OTHERS]):
        sys.stderr.write('--recursive/-r and --cumulative/-c have no effect on "{0}" statistic\n'.format(args.stat))

    # prepend the provided paths with the GUFI root path
    args.path = os.path.normpath(os.path.sep.join([config.indexroot(), args.path]))

    # create the query command
    query_cmd = [
        config.query(),
        '-n', str(config.threads()),
        '-B', str(config.outputbuffer()),
        '-d', args.delim
    ] + stats[args.stat](config, args, build_where(args))

    if args.skip:
        query_cmd += ['-k', args.skip]

    if args.verbose:
        gufi_common.print_query(query_cmd + [args.path])

    query = subprocess.Popen(query_cmd + [args.path]) # pylint: disable=consider-using-with
    query.communicate()                               # block until query finishes

    return query.returncode

if __name__ == '__main__':
    sys.exit(run(sys.argv, gufi_config.config_path()))
