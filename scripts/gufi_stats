#!/usr/bin/env python2.7
# This file is part of GUFI, which is part of MarFS, which is released
# under the BSD license.
#
#
# Copyright (c) 2017, Los Alamos National Security (LANS), LLC
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# From Los Alamos National Security, LLC:
# LA-CC-15-039
#
# Copyright (c) 2017, Los Alamos National Security, LLC All rights reserved.
# Copyright 2017. Los Alamos National Security, LLC. This software was produced
# under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National
# Laboratory (LANL), which is operated by Los Alamos National Security, LLC for
# the U.S. Department of Energy. The U.S. Government has rights to use,
# reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR LOS
# ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR
# ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is
# modified to produce derivative works, such modified software should be
# clearly marked, so as not to confuse it with the version available from
# LANL.
#
# THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.



import argparse
import exceptions
import itertools
import os
import subprocess
import sys

import gufi_common
import gufi_config

# Examples with their commands prefixed by '#' are run as root.
# Examples with their commands prefixed by '$' are run as user 1001.
# The source directory indexed into <prefix>.gufi has the following structure:
#
# <prefix>/                  #
# |---- 1001/                # owned by 1001:1001
#       |---- f1             # size 1
#       |---- l1 -> f1
# |---- 1002/                # owned by 1002:1002
#       |---- dir/           # empty
#             |---- f1       # size 2
#             |---- f2       # size 2
#             |---- l1 -> f1
#             |---- l2 -> f2
#       |---- f1             # size 2
#       |---- f2             # size 2
#       |---- l1 -> f1
#       |---- l2 -> f2
# |---- 1003/                # owned by 1003:1003
#       |---- f1             # size 3
#       |---- f2             # size 3
#       |---- f3             # size 3
#       |---- l1 -> f1
#       |---- l2 -> f2
#       |---- l3 -> f3
#

def build_create(name, columns):
    return 'CREATE TABLE {0}({1})'.format(name, ', '.join(columns))

def build_where(args, root_uid = 0, root_gid = 0):
    where = []

    # if not ((os.geteuid() == root_uid) or (os.getegid() == root_gid)):
    #     where  += ['(uid == {})'.format(os.getuid())]
    #     # where  += ['(uid == {}) OR (gid in {})'.format(os.getuid(), '(' + str(os.getgroups())[1:-1] + ')')]

    if args.uid:
        where += ['uid == "{}"'.format(args.uid)]

    return where

def depth(config, args, where):
    '''
    get the depths of the provided directories relative to the root directory

    using --recursive/-r here will search for all directories under the provided directory as well

    # gufi_stats depth
    0

    # gufi_stats depth -r
    . 0
    1001 1
    1002 1
    1002/dir 2
    1003 1

    # gufi_stats depth 1002
    1

    # gufi_stats depth 1002/dir
    2

    # gufi_stats -r depth 1002
    1002 1
    1002/dir 2

    $ gufi_stats -r depth
    . 0
    1001 1
    '''

    root_slash_count = config['IndexRoot'].count('/')
    root_len = len(config['IndexRoot'])

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT', 'level INT64']),

        '-S', 'INSERT INTO {} {} '.format(args.inmemory_name,
                                          gufi_common.build_query(['path() || "/" || name AS fullpath', '0'],
                                                                  ['summary'],
                                                                  where,
                                                                  None,
                                                                  None,
                                                                  args.num_results,
                                                                  None)),

        '-J', 'INSERT INTO aggregate.{} {} '.format(args.inmemory_name,
                                                    gufi_common.build_query(['substr(name, {})'.format(root_len + 2),
                                                                             '(length(name) - length(replace(name, "/", ""))) - {}'.format(root_slash_count)],
                                                                            [args.inmemory_name],
                                                                            None,
                                                                            None,
                                                                            None,
                                                                            None,
                                                                            None)),

        '-G', gufi_common.build_query((['CASE length(name) WHEN 0 THEN "." ELSE name END'] if args.recursive else []) +
                                      ['level'],
                                      [args.inmemory_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '0',
                    '-z', '0']

    return queries

def filesize(config, args, where):
    '''
    get the size the files in the immediate directory

    using --recursive here will get the size taken up by all of files in all subdirectories, without adding them

    # gufi_stats filesize
    0

    # gufi_stats -r filesize
    . 0
    1001 1
    1002 4
    1002/dir 4
    1003 9

    # gufi_stats filesize 1002
    4

    # gufi_stats -r filesize 1002
    1002 4
    1002/dir 4

    $ gufi_stats -r filesize
    . 0
    1001 1
    '''

    root_len = len(config['IndexRoot'])

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT', 'size INT64']),

        '-E', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                          gufi_common.build_query(['path()', 'CAST(TOTAL(size) as INT64)'],
                                                                  ['entries'],
                                                                  where + ['type == "f"'],
                                                                  None,
                                                                  None,
                                                                  args.num_results,
                                                                  None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['substr(name, {})'.format(root_len + 2), 'size'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           ['name ' + ORDER[args.order]] if args.order else None,
                                                                           args.num_results,
                                                                           None)),

        '-G', gufi_common.build_query((['CASE length(name) WHEN 0 THEN "." ELSE name END'] if args.recursive else []) +
                                      ['size'],
                                      [args.inmemory_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '0',
                    '-z', '0']

    return queries

def entries_count(config, args, where, type):
    '''
    get the number of <type>s in the immediate directory

    using --recursive here will get the number of <type> in all subdirectories, without adding them

    # gufi_stats <type>count
    0

    # gufi_stats -r <type>count
    . 0
    1001 1
    1002 2
    1002/dir 2
    1003 3

    # gufi_stats <type>count 1002
    2

    # gufi_stats -r <type>count 1002
    1002 2
    1002/dir 2

    $ gufi_stats -r <type>count
    . 0
    1001 1
    '''

    root_len = len(config['IndexRoot'])

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT', 'count INT64']),

        '-E', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['path() AS fullpath', 'COUNT(*)'],
                                                                 ['entries'],
                                                                 where + ['type == "{}"'.format(type)],
                                                                 None,
                                                                 None,
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['substr(name, {})'.format(root_len + 2), 'count'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           ['name ' + ORDER[args.order]] if args.order else None,
                                                                           args.num_results,
                                                                           None)),

        '-G', gufi_common.build_query((['CASE length(name) WHEN 0 THEN "." ELSE name END'] if args.recursive else []) +
                                      ['count'],
                                      [args.inmemory_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '0',
                    '-z', '0']

    return queries

def filecount(config, args, where):
    return entries_count(config, args, where, 'f')

def linkcount(config, args, where):
    return entries_count(config, args, where, 'l')

def total_filesize(config, args, where):
    '''
    get the total size taken up by the entire directory

    --cumulative collects all values and sums them instead of reporting by uid

    # gufi_stats total-filesize
    1001 1
    1002 8
    1003 9

    # gufi_stats -c total-filesize
    18

    # gufi_stats total-filesize 1002
    1002 8

    # gufi_stats -c total-filesize 1002
    8

    $ gufi_stats -c total-filesize
    1
    '''

    root_len = len(config['IndexRoot'])
    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(args.inmemory_name, ['id INTEGER PRIMARY KEY', 'uid INT64', 'size INT64']),

        '-E', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['NULL', 'uid', 'SUM(size)'],
                                                                 ['entries'],
                                                                 where + ['type == "f"'],
                                                                 group_by,
                                                                 ['uid {}'.format(ORDER[args.order]), 'size {}'.format(ORDER[args.order])],
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['NULL', 'uid', 'size'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           ['uid {}'.format(ORDER[args.order]), 'size {}'.format(ORDER[args.order])],
                                                                           args.num_results,
                                                                           None)),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid, 0)']) + ['SUM(size)'],
                                      [args.inmemory_name],
                                      None,
                                      group_by,
                                      ['uid {}'.format(ORDER[args.order]), 'size {}'.format(ORDER[args.order])],
                                      args.num_results,
                                      None),
    ]

    return queries

def total_entries_count(config, args, where, type):
    '''
    get the total number of <type>s under the directory

    --cumulative collects all values and sums them instead of reporting by uid

    # gufi_stats total-<type>count
    1001 1
    1003 3
    1002 4

    # gufi_stats -c total-<type>count
    8

    # gufi_stats total-<type>count 1002
    1002 4

    # gufi_stats -c total-<type>count 1002
    4

    $ gufi_stats -c total-<type>count
    1
    '''

    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(args.inmemory_name, ['id INTEGER PRIMARY KEY', 'uid INT64', 'count INT64']),

        '-E', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['NULL', 'uid', 'COUNT(*) AS count'],
                                                                 ['entries'],
                                                                 where + ['type == "{}"'.format(type)],
                                                                 group_by,
                                                                 ['count {}'.format(ORDER[args.order]), 'uid {}'.format(ORDER[args.order])],
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['NULL', 'uid', 'count'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           ['count {}'.format(ORDER[args.order]), 'uid {}'.format(ORDER[args.order])],
                                                                           args.num_results,
                                                                           None)),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid, 0)']) + ['SUM(count) AS count'],
                                      [args.inmemory_name],
                                      None,
                                      group_by,
                                      ['count {}'.format(ORDER[args.order]), 'uid {}'.format(ORDER[args.order])],
                                      args.num_results,
                                      None),
    ]

    return queries

def total_filecount(config, args, where):
    return total_entries_count(config, args, where, 'f')

def total_linkcount(config, args, where):
    return total_entries_count(config, args, where, 'l')

def dircount(config, args, where):
    '''
    get the number of directories in the immediate directory

    using --recursive here will get the number of directoriess in all subdirectories, without adding them

    # gufi_stats dircount
    3

    # gufi_stats -r dircount
    . 3
    1001 0
    1002 1
    1003 0

    # gufi_stats dircount 1002
    1

    # gufi_stats -r dircount 1002
    1002 1
    1002/dir 0

    ###########################################
    # This is wrong. This should be 3 but     #
    # without root, the other databases can't #
    # be accessed.                            #
    ###########################################
    $ gufi_stats -r dir-count
    . 1
    1001 0
    '''

    root_len = len(config['IndexRoot'])

    queries = [
        '-I', build_create(args.inmemory_name, ['path TEXT', 'inode INT64', 'pinode INT64']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['fpath()', 'inode', 'pinode'],
                                                                 ['summary'],
                                                                 where,
                                                                 None,
                                                                 None,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{0} SELECT * FROM {0}'.format(args.inmemory_name),

        '-G', gufi_common.build_query((['CASE (length(parent.path) - {0}) WHEN 0 THEN "." ELSE substr(parent.path, {1}) END'.format(root_len, root_len + 2)] if args.recursive else []) +
                                      ['IFNULL(COUNT(child.pinode), 0) END'],
                                      ['out parent LEFT JOIN out child On parent.inode == child.pinode'],
                                      where + ([] if args.recursive else ['parent.path == "{}"'.format(args.path)]),
                                      ['parent.inode'],
                                      ['parent.path'],
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += [
            '-y', '0',
            '-z', '1']

    return queries

def total_dircount(config, args, where):
    '''
    get the total number of directories under the directory

    --cumulative collects all values and sums them instead of reporting by uid

    # gufi_stats total-dircount
    1001 1
    1003 1
    1002 2

    # gufi_stats -c total-dircount
    4

    # gufi_stats total-dircount 1002
    1002 1

    # gufi_stats -c total-dircount 1002
    1

    $ gufi_stats -c total-dircount
    1
    '''

    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(args.inmemory_name, ['id INTEGER PRIMARY KEY', 'uid INT64', 'count INT64']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['NULL', 'uid', '1 as count'],
                                                                 ['summary'],
                                                                 where + ['level() > 0'],
                                                                 group_by,
                                                                 ['count {}'.format(ORDER[args.order]), 'uid {}'.format(ORDER[args.order])],
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['NULL', 'uid', 'count'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           ['count {}'.format(ORDER[args.order]), 'uid {}'.format(ORDER[args.order])],
                                                                           args.num_results,
                                                                           None)),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid, 0)']) + ['SUM(count) AS count'],
                                      [args.inmemory_name],
                                      None,
                                      group_by,
                                      ['count {}'.format(ORDER[args.order]), 'uid {}'.format(ORDER[args.order])],
                                      args.num_results,
                                      None),
    ]

    return queries

def leaf_dirs(config, args, where):
    '''
    get the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well

    # gufi_stats leaf-dirs
    1001
    1003

    # gufi_stats -r leaf-dirs
    1001
    1002/dir
    1003

    # gufi_stats leaf-dirs 1002
    1002/dir

    # gufi_stats -r leaf-dirs 1002
    1002/dir

    # gufi_stats -r leaf-dirs
    1001
    '''

    root_len = len(config['IndexRoot'])

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['path() || "/" || name'],
                                                                 ['summary'],
                                                                 where + ['nlink == 2'],
                                                                 None,
                                                                 None,
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['substr(name, {})'.format(root_len + 2)],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           None,
                                                                           None,
                                                                           None)),

        '-G', gufi_common.build_query(['CASE length(name) WHEN 0 THEN "." ELSE name END'],
                                      [args.inmemory_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '1',
                    '-z', '1']

    return queries

def leaf_depth(config, args, where):
    '''
    get the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well

    # gufi_stats leaf-depth
    1001 1
    1003 1

    # gufi_stats -r leaf-depth
    1001 1
    1002/dir 2
    1003 1

    # gufi_stats leaf-depth 1002
    1002/dir 2

    # gufi_stats -r leaf-depth 1002
    1002/dir 2

    $ gufi_stats -r leaf-depth
    1001 1
    '''

    root_slash_count = config['IndexRoot'].count('/')
    root_len = len(config['IndexRoot'])

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT', 'level INT64']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['(path() || "/" || name) AS fullpath', '0'],
                                                                 ['summary'],
                                                                 where + ['nlink == 2'],
                                                                 None,
                                                                 None,
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['substr(name, {})'.format(root_len + 2),
                                                                            '(length(name) - length(replace(name, "/", ""))) - {}'.format(root_slash_count)],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           None,
                                                                           None,
                                                                           None)),

        '-G', gufi_common.build_query(['name', 'level'],
                                      [args.inmemory_name],
                                      None,
                                      None,
                                      ['name ' + ORDER[args.order]] if args.order else None,
                                      args.num_results,
                                      None),
    ]

    if not args.recursive:
        queries += ['-y', '1',
                    '-z', '1']

    return queries

def leaf_files(config, args, where):
    '''
    get number of files in the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well

    # gufi_stats leaf-files
    1001 1
    1003 3

    # gufi_stats leaf-files -r
    1001 1
    1002/dir 2
    1003 3

    # gufi_stats leaf-files 1002
    1002/dir 2

    # gufi_stats leaf-files -r 1002
    1002/dir 2

    $ gufi_stats leaf-files -r
    1001 1
    '''

    root_len = len(config['IndexRoot'])

    queries = [
        '-I', build_create(args.inmemory_name, ['name TEXT', 'count INT64']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['path() || "/" || name', '(SELECT COUNT(*) FROM entries)'],
                                                                 ['summary'],
                                                                 where + ['nlink == 2'],
                                                                 None,
                                                                 None,
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.out ' + gufi_common.build_query(['substr(name, {})'.format(root_len + 2),
                                                                      'count'],
                                                                     [args.inmemory_name],
                                                                     None,
                                                                     None,
                                                                     None,
                                                                     None,
                                                                     None),

        '-G',                                gufi_common.build_query(['name', 'count'],
                                                                     [args.inmemory_name],
                                                                     None,
                                                                     None,
                                                                     ['name ' + ORDER[args.order]] if args.order else None,
                                                                     args.num_results,
                                                                     None),
    ]

    if not args.recursive:
        queries += ['-y', '1',
                    '-z', '1']

    return queries

def total_leaf_files(config, args, where):
    '''
    get total number of files in the leaf directories under this directory

    --cumulative collects all values and sums them instead of reporting by uid

    # gufi_stats total-leaf-files
    1001 1
    1002 2
    1003 3

    # gufi_stats -c total-leaf-files
    6

    # gufi_stats total-leaf-files 1002
    1002 2

    # gufi_stats -c total-leaf-files 1002
    2

    $ gufi_stats -c total-leaf-files
    1
    '''

    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(args.inmemory_name, ['uid INT64', 'count INT64']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['uid', '(SELECT COUNT(*) FROM entries) AS count'],
                                                                 ['summary'],
                                                                 where + ['nlink == 2'],
                                                                 group_by,
                                                                 ['uid {}'.format(ORDER[args.order]), 'count {}'.format(ORDER[args.order])],
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['uid', 'SUM(count) AS count'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           group_by,
                                                                           ['uid {}'.format(ORDER[args.order]), 'count {}'.format(ORDER[args.order])],
                                                                           args.num_results,
                                                                           None)),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid, 0)']) + ['SUM(count) AS count'],
                                      [args.inmemory_name],
                                      None,
                                      group_by,
                                      ['uid {}'.format(ORDER[args.order]), 'count {}'.format(ORDER[args.order])],
                                      args.num_results,
                                      None),
    ]

    return queries

def median_leaf_files(config, args, where):
    '''
    get median number of leaf directories under the provided directory

    --recursive is ignored

    # gufi_stats median-leaf-files
    2.0

    # gufi_stats median-leaf-files 1002
    2.0

    $ gufi_stats median-leaf-files
    1.0
    '''

    group_by = None if args.recursive else ['uid']

    queries = [
        '-I', build_create(args.inmemory_name, ['uid INT64', 'count INT64']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['uid', '(SELECT COUNT(*) FROM entries) AS count'],
                                                                 ['summary'],
                                                                 where + ['nlink == 2'],
                                                                 None,
                                                                 None,
                                                                 args.num_results,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['uid', 'count'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           None,
                                                                           None,
                                                                           None)),

        # Adapter from answer by CL
        # https://stackoverflow.com/a/15766121
        '-G', '''SELECT AVG(count)
                 FROM (SELECT count
                       FROM {0}
                       ORDER BY count
                       LIMIT 2 - (SELECT COUNT(*) FROM {0}) % 2    -- odd 1, even 2
                                  OFFSET (SELECT (COUNT(*) - 1) / 2
                                          FROM {0})
                      )'''.format(args.inmemory_name)
    ]

    return queries

def per_level(config, args, where, type):
    '''
    get counts of how many <type>s are in each level of the tree, by uid

    --cumulative combines the results into one set of distributions

    # #########################################
    # files and links #########################

    # gufi_stats <type>s-per-level
    1001 1 1
    1002 1 2
    1003 1 3
    1002 2 2

    # gufi_stats -c <type>s-per-level
    1 6
    2 2

    # gufi_stats <type>s-per-level 1002
    1002 1 2
    1002 2 2

    # gufi_stats -c <type>s-per-level 1002
    1 2
    2 2

    $ gufi_stats -c <type>s-per-level
    1 1
    # #########################################

    # #########################################
    # directories
    # gufi_stats dirs-per-level
    1001 1 1
    1002 1 1
    1003 1 1
    1002 2 1

    # gufi_stats -c dirs-per-level
    1 3
    2 1

    # gufi_stats dirs-per-level 1002
    1002 1 1
    1002 2 1

    # gufi_stats -c dirs-per-level 1002
    1 1
    2 1

    $ gufi_stats -c dirs-per-level
    1 1
    # #########################################
    '''

    root = os.path.normpath(config['IndexRoot'])
    root_len = len(root)
    path = os.path.normpath(args.path)
    path_len = len(path)
    starting_depth = 0
    if path_len != root_len:
        starting_depth = path[root_len - path_len:].count('/')

    group_by = ['level'] + ([] if args.cumulative else ['uid'])
    order_by = None if args.cumulative else ['level {}'.format(ORDER[args.order]), 'uid {}'.format(ORDER[args.order])]

    uid = [] if args.cumulative else ['uid']
    count = '1' if type == 'd' else '(SELECT COUNT(*) FROM entries WHERE type == "{}")'.format(type)

    queries = [
        '-I', build_create(args.inmemory_name, ['id INT PRIMARY KEY'] + ([] if args.cumulative else ['uid INT64']) + ['level INT64', 'count INT64']),

        '-S', 'INSERT INTO {} {}'.format(args.inmemory_name,
                                         gufi_common.build_query(['NULL'] + uid + ['level() + {}'.format(starting_depth), count],
                                                                 ['summary'],
                                                                 where,
                                                                 ['uid'],
                                                                 None,
                                                                 None,
                                                                 None)),

        '-J', 'INSERT INTO aggregate.{} {}'.format(args.inmemory_name,
                                                   gufi_common.build_query(['NULL'] + uid + ['level', 'SUM(count)'],
                                                                           [args.inmemory_name],
                                                                           None,
                                                                           group_by,
                                                                           order_by,
                                                                           None,
                                                                           None)),

        '-G', gufi_common.build_query(([] if args.cumulative else ['uidtouser(uid, 0)']) + ['level', 'SUM(count)'],
                                      [args.inmemory_name],
                                      ['level <> 0', 'count <> 0'],
                                      group_by,
                                      order_by,
                                      args.num_results,
                                      None),

    ]

    return queries

def files_per_level(config, args, where):
    return per_level(config, args, where, 'f')

def links_per_level(config, args, where):
    return per_level(config, args, where, 'l')

def dirs_per_level(config, args, where):
    return per_level(config, args, where, 'd')

# mapping of desired statistics to functions
# uses --recursive
RECURSIVE = {
    'depth'              : depth,
    'filesize'           : filesize,
    'filecount'          : filecount,
    'linkcount'          : linkcount,
    'dircount'           : dircount,
    'leaf-dirs'          : leaf_dirs,
    'leaf-depth'         : leaf_depth,
    'leaf-files'         : leaf_files,
}

# uses --cumulative
CUMULATIVE = {
    'total-filesize'     : total_filesize,
    'total-filecount'    : total_filecount,
    'total-linkcount'    : total_linkcount,
    'total-dircount'     : total_dircount,
    'total-leaf-files'   : total_leaf_files,
    'files-per-level'    : files_per_level,
    'links-per-level'    : links_per_level,
    'dirs-per-level'     : dirs_per_level,
}

# does not use either
OTHERS = {
    'median-leaf-files'  : median_leaf_files,
}

# allowed keywords for sorting output (if applicable)
ASCENDING  = 'ASC'
DESCENDING = 'DESC'
ORDER = {'ASC'   : ASCENDING,
         'DESC'  : DESCENDING,
         'least' : ASCENDING,
         'most'  : DESCENDING}

if __name__=='__main__':
    STATS = {}
    STATS.update(RECURSIVE)
    STATS.update(CUMULATIVE)
    STATS.update(OTHERS)

    # find and parse the configuration file first
    config = gufi_config.server_config(gufi_config.DEFAULT_CONFIG_PATH)

    # parse the arguments
    parser = argparse.ArgumentParser(description='GUFI statistics', add_help=False)

    # override help to not use -h
    parser.add_argument('--help',                                                   action='help',                                         help='show this help message and exit')
    parser.add_argument('--version', '-v',                                          action='version',          version=os.path.basename(os.path.realpath(__file__)) + ' @GUFI_VERSION@')
    parser.add_argument('--recursive', '-r',                  dest='recursive',     action='store_true',                                   help='run command recursively ({})'.format(', '.join(RECURSIVE.keys())))
    parser.add_argument('--cumulative', '-c',                 dest='cumulative',    action='store_true',                                   help='return cumulative values ({})'.format(', '.join(CUMULATIVE.keys())))
    parser.add_argument('--order',           metavar='order', dest='order',         choices=ORDER.keys(),               default=ASCENDING, help='sort output (if applicable)')
    parser.add_argument('--delim',           metavar='c',     dest='delim',         type=gufi_common.get_char,          default=' ',       help='delimiter separating output columns')
    parser.add_argument('--num_results',     metavar='n',     dest='num_results',   type=gufi_common.get_non_negative,                     help='first n results')
    parser.add_argument('--uid', '--user',   metavar='u',     dest='uid',           type=gufi_common.get_uid,                              help='restrict to user')
    parser.add_argument('--output-buffer',   metavar='bytes', dest='output_buffer', type=gufi_common.get_positive,      default=4096,      help='Size of each thread\'s output buffer')
    parser.add_argument('--in-memory-name',  metavar='name',  dest='inmemory_name', type=str,                           default='out',     help='Name of in-memory database when -R is used')
    parser.add_argument('stat',                                                     choices=STATS.keys(), help='statistic to get')
    parser.add_argument('path',                                                     type=str, nargs='?',                default='')

    args = parser.parse_args();

    # check args
    if args.recursive and (args.stat in CUMULATIVE):
        sys.stderr.write('--recursive/-r has no effect on "{}" statistic\n'.format(args.stat))
    if args.cumulative and (args.stat in RECURSIVE):
        sys.stderr.write('--cumulative/-c has no effect on "{}" statistic\n'.format(args.stat))
    if (args.recursive or args.cumulative) and (args.stat in OTHERS):
        sys.stderr.write('--recursive/-r and --cumulative/-c have no effect on "{}" statistic\n'.format(args.stat))

    # prepend the provided paths with the GUFI root path
    args.path = os.path.normpath(os.path.sep.join([config['IndexRoot'], args.path]))

    # create the query command
    query_cmd = [config['Exec'],
                 '-e', '0',
                 '-n', str(config['Threads']),
                 '-B', str(args.output_buffer),
                 '-d', args.delim] + STATS[args.stat](config, args, build_where(args))

    query = subprocess.Popen(query_cmd + [args.path])
    query.communicate() # block until query finishes

    sys.exit(query.returncode)
