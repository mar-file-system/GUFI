#!@Python3_EXECUTABLE@
# This file is part of GUFI, which is part of MarFS, which is released
# under the BSD license.
#
#
# Copyright (c) 2017, Los Alamos National Security (LANS), LLC
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# From Los Alamos National Security, LLC:
# LA-CC-15-039
#
# Copyright (c) 2017, Los Alamos National Security, LLC All rights reserved.
# Copyright 2017. Los Alamos National Security, LLC. This software was produced
# under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National
# Laboratory (LANL), which is operated by Los Alamos National Security, LLC for
# the U.S. Department of Energy. The U.S. Government has rights to use,
# reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR LOS
# ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR
# ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is
# modified to produce derivative works, such modified software should be
# clearly marked, so as not to confuse it with the version available from
# LANL.
#
# THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.



from collections import OrderedDict
import argparse
import os
import subprocess
import sys
import time

# these are used a lot
from gufi_common import SQLITE3_INTEGER, SQLITE3_INT64, SQLITE3_TEXT, SQLITE3_IPK, SQLITE3_ASC, SQLITE3_DESC
from gufi_common import VRPENTRIES, VRSUMMARY, INTERMEDIATE_NAME, AGGREGATE_NAME
from gufi_common import build_query

import gufi_common
import gufi_config

PATH = 'path'
PATH_CREATE = '{0} {1}'.format(PATH, SQLITE3_TEXT)

# convenience function
def path_sql(args):
    path_create = [PATH_CREATE] if args.recursive else []
    E_path = ['rpath(sname, sroll) AS {0}'.format(PATH)] if args.recursive else []
    path = [PATH] if args.recursive else []
    return path_create, E_path, path

# Examples are outputs generated by running gufi_stats
# on the index of the tree generated by test/generatetree

# allowed keywords for sorting output (if applicable)
ORDER = {'ASC'   : SQLITE3_ASC,
         'DESC'  : SQLITE3_DESC,
         'least' : SQLITE3_ASC,
         'most'  : SQLITE3_DESC}

def build_create(name, columns):
    return 'CREATE TABLE {0}({1})'.format(name, ', '.join(columns))

def build_where(args, root_uid=0, root_gid=0): # pylint: disable=unused-argument
    where = []

    # if not ((os.geteuid() == root_uid) or (os.getegid() == root_gid)):
    #     where  += ['(uid == {0})'.format(os.getuid())]

    if args.uid is not None:
        where += ['uid == \'{0}\''.format(args.uid)]

    return where

def depth(config, args, where):
    '''
    get the depths of the provided directories relative to the root directory

    using --recursive/-r here will search for all directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, ['name {0}'.format(SQLITE3_TEXT)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2)],
                                                       [VRSUMMARY],
                                                       where,
                                                       None,
                                                       None,
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, ['name {0}'.format(SQLITE3_TEXT)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['*'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query((['CASE length(name) WHEN 0 THEN \'.\' ELSE name END'] if args.recursive else []) +
                          ['CASE length(name) WHEN 0 THEN 0 ELSE length(name) - length(replace(name, \'/\', \'\')) + 1 END'],
                          [AGGREGATE_NAME],
                          None,
                          None,
                          ['name ' + ORDER[args.order]] if args.order else None,
                          args.num_results,
                          None),
    ]

    if not args.recursive:
        queries += ['--min-level', '0',
                    '--max-level', '0']

    return queries

def filesize(config, args, where):
    '''
    get the size the files in the immediate directory

    using --recursive here will get the size taken up by all of files
    in all subdirectories, without adding them
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, ['name {0}'.format(SQLITE3_TEXT), 'size {0}'.format(SQLITE3_INT64)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2),
                                                        'CAST(TOTAL(size) AS {0})'.format(SQLITE3_INT64)],
                                                       [VRPENTRIES],
                                                       where + ['type == \'f\''],
                                                       None,
                                                       None,
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, ['name {0}'.format(SQLITE3_TEXT), 'size {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['name', 'size'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       ['name ' + ORDER[args.order]] if args.order else None,
                                                       args.num_results,
                                                       None)),

        '-G', build_query((['CASE length(name) WHEN 0 THEN \'.\' ELSE name END'] if args.recursive else []) +
                          ['size'],
                          [AGGREGATE_NAME],
                          None,
                          None,
                          ['name ' + ORDER[args.order]] if args.order else None,
                          args.num_results,
                          None),
    ]

    if not args.recursive:
        queries += ['--min-level', '0',
                    '--max-level', '0']

    return queries

def entries_count(config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get the number of <type>s in the immediate directory

    using --recursive here will get the number of <type> in all subdirectories, without adding them
    '''

    queries = [
        '-E', build_query((['substr(rpath({0}.name, {0}.rollupscore), {1})'.format(VRSUMMARY, len(config.indexroot) + 2)] if args.recursive else []) +
                          ['COUNT({0}.inode)'.format(VRPENTRIES)],
                          ['{0} LEFT JOIN {1} ON (({0}.inode == {1}.pinode) AND {1}.type == \'{2}\')'.format(VRSUMMARY, VRPENTRIES, type)],
                          where,
                          ['{0}.inode'.format(VRSUMMARY)],
                          None,
                          None,
                          None)
    ]

    if not args.recursive:
        queries += ['--min-level', '0',
                    '--max-level', '0']

    return queries

def filecount(config, args, where):
    return entries_count(config, args, where, 'f')

def linkcount(config, args, where):
    return entries_count(config, args, where, 'l')

def extensions(_config, args, where):
    '''
    get file extension histogram
    files without extensions ('Makefile') are placed in the 'no-ext' category

    with --recursive, groups results by path
    with --cumulative, sums all results

    '''

    path_create, E_path, path = path_sql(args)

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, path_create + ['ext {0}'.format(SQLITE3_TEXT), 'count {0}'.format(SQLITE3_INTEGER)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           # Adapted from answer by rayzinnz
                                           # https://stackoverflow.com/a/76040173
                                           build_query(E_path + ['CASE WHEN name LIKE \'%.%\' THEN REPLACE(name, RTRIM(name, REPLACE(name, \'.\', \'\')), \'\') ELSE \'no-ext\' END AS ext', 'COUNT(*)'],
                                                       [VRPENTRIES],
                                                       where,
                                                       path + ['ext'],
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, path_create  + ['ext {0}'.format(SQLITE3_TEXT), 'count {0}'.format(SQLITE3_INTEGER)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(path + ['ext', 'SUM(count)'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       path + ['ext'],
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(path + ['ext', 'SUM(count)'],
                          [AGGREGATE_NAME],
                          None,
                          path + ['ext'],
                          path,
                          None,
                          None),
    ]

    if not args.recursive and not args.cumulative:
        queries += ['--max-level', '0']

    return queries

def extensions_hist(_config, args, where):
    '''
    get file extension histogram
    files without extensions ('Makefile') are placed in the 'no-ext' category

    with --recursive, groups results by path
    with --cumulative, sums all results

    '''

    path_create, E_path, path = path_sql(args)

    # G column
    res_sql = ['extension_hist_combine(ext, 1)' if not args.recursive else 'ext']

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, path_create + ['ext {0}'.format(SQLITE3_TEXT)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           # Adapted from answer by rayzinnz
                                           # https://stackoverflow.com/a/76040173
                                           build_query(E_path + ['extension_hist(name, 1, 0)'],
                                                       [VRPENTRIES],
                                                       where,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, path_create + ['ext {0}'.format(SQLITE3_TEXT)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(path + ['ext'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(path + res_sql,
                          [AGGREGATE_NAME],
                          None,
                          None,
                          path,
                          None,
                          None),
    ]

    if not args.recursive and not args.cumulative:
        queries += ['--max-level', '0']

    return queries

def total_filesize(_config, args, where):
    '''
    get the total size taken up by the entire directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    queries = []
    if args.cumulative:
        queries = [
            '-I', build_create(INTERMEDIATE_NAME,
                               ['id {0}'.format(SQLITE3_IPK),
                                'size {0}'.format(SQLITE3_INT64)]),

            '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                               build_query(['NULL', 'totsize'],
                                                           [VRSUMMARY],
                                                           where,
                                                           None,
                                                           None,
                                                           None,
                                                           None)),

            '-K', build_create(AGGREGATE_NAME, ['id {0}'.format(SQLITE3_IPK),
                                                'size {0}'.format(SQLITE3_INT64)]),

            '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                               build_query(['NULL', 'size'],
                                                           [INTERMEDIATE_NAME],
                                                           None,
                                                           None,
                                                           None,
                                                           None,
                                                           None)),

            '-G', build_query(['SUM(size)'],
                              [AGGREGATE_NAME],
                              None,
                              None,
                              None,
                              None,
                              None),
        ]

    else:
        group_by = ['uid']
        order_by = ['uid {0}' .format(ORDER[args.order]),
                    'size {0}'.format(ORDER[args.order])]

        queries = [
            '-I', build_create(INTERMEDIATE_NAME,
                               ['id {0}'.format(SQLITE3_IPK),
                                'uid {0}'.format(SQLITE3_INT64),
                                'size {0}'.format(SQLITE3_INT64)]),

            '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                               build_query(['NULL', 'uid', 'SUM(size)'],
                                                           [VRPENTRIES],
                                                           where + ['type == \'f\''],
                                                           group_by,
                                                           order_by,
                                                           args.num_results,
                                                           None)),

            '-K', build_create(AGGREGATE_NAME,
                               ['id {0}'.format(SQLITE3_IPK),
                                'uid {0}'.format(SQLITE3_INT64),
                                'size {0}'.format(SQLITE3_INT64)]),

            '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                               build_query(['NULL', 'uid', 'size'],
                                                           [INTERMEDIATE_NAME],
                                                           None,
                                                           None,
                                                           order_by,
                                                           args.num_results,
                                                           None)),

            '-G', build_query(['uidtouser(uid)', 'SUM(size)'],
                              [AGGREGATE_NAME],
                              None,
                              group_by,
                              order_by,
                              args.num_results,
                              None),
        ]

    return queries

def total_entries_count(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get the total number of <type>s under the directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    group_by = None if args.cumulative else ['uid']

    E_group_by = [PATH]      # pylint: disable=invalid-name
    if group_by is not None:
        E_group_by += group_by # pylint: disable=invalid-name

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK),
                            'uid {0}'.format(SQLITE3_INT64),
                            PATH_CREATE,
                            'count {0}'.format(SQLITE3_INT64)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['NULL', 'uid',
                                                        'rpath(sname, sroll, name) AS path',
                                                        'COUNT(inode) AS count'],
                                                       [VRPENTRIES],
                                                       where + ['type == \'{0}\''.format(type)],
                                                       E_group_by,
                                                       ['count {0}'.format(ORDER[args.order]),
                                                        'uid {0}'.format(ORDER[args.order])],
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK),
                            'uid {0}'.format(SQLITE3_INT64),
                            PATH_CREATE,
                            'count {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['NULL', 'uid',
                                                        PATH, 'count'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       ['count {0}'.format(ORDER[args.order]),
                                                        'uid {0}'.format(ORDER[args.order])],
                                                       args.num_results,
                                                       None)),

        '-G', build_query(([] if args.cumulative else ['uidtouser(uid)']) + ['SUM(count) AS count'],
                          [AGGREGATE_NAME],
                          None,
                          group_by,
                          ['count {0}'.format(ORDER[args.order]),
                           'uid {0}'.format(ORDER[args.order])],
                          args.num_results,
                          None),
    ]

    return queries

def total_filecount(config, args, where):
    return total_entries_count(config, args, where, 'f')

def total_linkcount(config, args, where):
    return total_entries_count(config, args, where, 'l')

def dircount(config, args, where):
    '''
    get the number of subdirectories in the immediate directory

    using --recursive here will get the number of directoriess in all subdirectories, without adding them

    ############################################
    # This is wrong when running as a non-root #
    # user. Without root, the other databases  #
    # can't be accessed.                       #
    ############################################
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           [PATH_CREATE,
                            'inode {0}'.format(SQLITE3_INT64),
                            'pinode {0}'.format(SQLITE3_TEXT),
                            'level {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2),
                                                        'inode', 'pinode', 'level()'],
                                                       [VRSUMMARY],
                                                       ([] if args.recursive else ['isroot == 1']) + where,
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           [PATH_CREATE,
                            'inode {0}'.format(SQLITE3_INT64),
                            'pinode {0}'.format(SQLITE3_TEXT),
                            'level {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query([PATH, 'inode', 'pinode', 'level'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query((['CASE length(path) WHEN 0 THEN \'.\' ELSE path END as print_path'] if args.recursive else []) +
                          ['(SELECT COUNT(*) FROM {0} AS nested WHERE nested.pinode == {0}.inode)'.format(AGGREGATE_NAME)],
                          [AGGREGATE_NAME],
                          None if args.recursive else ['level == 0'],
                          None,
                          ['print_path ASC'] if args.recursive else None,
                          None),
    ]

    if not args.recursive:
        queries += [
            '--min-level', '0',
            '--max-level', '2']

    return queries

def total_dircount(_config, args, where):
    '''
    get the total number of directories under the directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK),
                            'name {0}'.format(SQLITE3_TEXT),
                            'uid {0}'.format(SQLITE3_INT64),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['NULL', 'name', 'uid', '1 as count'],
                                                       [VRSUMMARY],
                                                       where +
                                                       [] if args.cumulative else [gufi_common.ROLLUP_SUMMARY_WHERE],
                                                       group_by,
                                                       ['count {0}'.format(ORDER[args.order]),
                                                        'uid {0}'.format(ORDER[args.order])],
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK),
                            'name {0}'.format(SQLITE3_TEXT),
                            'uid {0}'.format(SQLITE3_INT64),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['NULL', 'name', 'uid', 'count'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       ['count {0}'.format(ORDER[args.order]),
                                                        'uid {0}'.format(ORDER[args.order])],
                                                       args.num_results,
                                                       None)),

        '-G', build_query(([] if args.cumulative else ['uidtouser(uid)']) +
                          ['SUM(count) ' + ('' if args.cumulative else '+ 1') + ' AS count'],
                          [AGGREGATE_NAME],
                          None,
                          group_by,
                          ['count {0}'.format(ORDER[args.order]),
                           'uid {0}'.format(ORDER[args.order])],
                          args.num_results,
                          None),
    ]

    return queries

def leaf_dirs(config, args, where):
    '''
    get the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['name {0}'.format(SQLITE3_TEXT)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2)],
                                                       [VRSUMMARY],
                                                       where + ['nlink == 2'],
                                                       None,
                                                       None,
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['name {0}'.format(SQLITE3_TEXT)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['name'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(['CASE length(name) WHEN 0 THEN \'.\' ELSE name END'],
                          [AGGREGATE_NAME],
                          None,
                          None,
                          ['name ' + ORDER[args.order]] if args.order else None,
                          args.num_results,
                          None),
    ]

    if not args.recursive:
        queries += ['--min-level', '1',
                    '--max-level', '2']

    return queries

def leaf_depth(config, args, where):
    '''
    get the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['name {0}'.format(SQLITE3_TEXT),
                            'level {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2), '0'],
                                                       [VRSUMMARY],
                                                       where + ['nlink == 2'],
                                                       None,
                                                       None,
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['name {0}'.format(SQLITE3_TEXT),
                            'level {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['name',
                                                        '(length(name) - length(replace(name, \'/\', \'\'))) + 1'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(['name', 'level'],
                          [AGGREGATE_NAME],
                          None,
                          None,
                          ['name ' + ORDER[args.order]] if args.order else None,
                          args.num_results,
                          None),
    ]

    if not args.recursive:
        queries += ['--min-level', '1',
                    '--max-level', '2']

    return queries

def leaf(config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get number of <type>s in the leaf directories immediately under the current directory

    using --recursive/-r here will search for leaf directories under the provided directory as well
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['name {0}'.format(SQLITE3_TEXT),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2), '(SELECT COUNT(*) FROM entries WHERE type == \'{0}\')'.format(type)],
                                                       [VRSUMMARY],
                                                       where + ['nlink == 2'],
                                                       None,
                                                       None,
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['name {0}'.format(SQLITE3_TEXT),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['name', 'count'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(['name', 'count'],
                          [AGGREGATE_NAME],
                          None,
                          None,
                          ['name ' + ORDER[args.order]] if args.order else None,
                          args.num_results,
                          None),
    ]

    if not args.recursive:
        queries += ['--min-level', '1',
                    '--max-level', '2']

    return queries

def leaf_files(config, args, where):
    return leaf(config, args, where, 'f')

def leaf_links(config, args, where):
    return leaf(config, args, where, 'l')

def total_leaf(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get total number of <type>s in the leaf directories under this directory

    --cumulative collects all values and sums them instead of reporting by uid
    '''

    group_by = None if args.cumulative else ['uid']

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['uid {0}'.format(SQLITE3_INT64),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['uid', '(SELECT COUNT(*) FROM entries WHERE type== \'{0}\') AS count'.format(type)],
                                                       [VRSUMMARY],
                                                       where + ['nlink == 2'],
                                                       group_by,
                                                       ['uid {0}'.format(ORDER[args.order]),
                                                        'count {0}'.format(ORDER[args.order])],
                                                       args.num_results,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['uid {0}'.format(SQLITE3_INT64),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['uid', 'SUM(count) AS count'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       group_by,
                                                       ['uid {0}'.format(ORDER[args.order]),
                                                        'count {0}'.format(ORDER[args.order])],
                                                       args.num_results,
                                                       None)),

        '-G', build_query(([] if args.cumulative else ['uidtouser(uid)']) + ['SUM(count) AS count'],
                          [AGGREGATE_NAME],
                          None,
                          group_by,
                          ['uid {0}'.format(ORDER[args.order]),
                           'count {0}'.format(ORDER[args.order])],
                          args.num_results,
                          None),
    ]

    return queries

def total_leaf_files(config, args, where):
    return total_leaf(config, args, where, 'f')

def total_leaf_links(config, args, where):
    return total_leaf(config, args, where, 'l')

def average_leaf(_config, _args, where, col):
    '''
    get average number of leaf <col> under the provided directory
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, ['val {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query([col],
                                                       [VRSUMMARY],
                                                       where + ['nlink == 2'],
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, ['val {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['val'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(['AVG(val)'],
                          [AGGREGATE_NAME],
                          None,
                          None,
                          None,
                          None,
                          None)
    ]

    return queries

def average_leaf_files(config, args, where):
    return average_leaf(config, args, where, 'totfiles')

def average_leaf_links(config, args, where):
    return average_leaf(config, args, where, 'totlinks')

def average_leaf_size(config, args, where):
    return average_leaf(config, args, where, 'totsize')

def median_leaf(_config, _args, where, col):
    '''
    get median number of leaf files under the provided directory
    '''

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, ['count {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query([col],
                                                       [VRSUMMARY],
                                                       where + ['nlink == 2'],
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, ['count {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['count'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        # Adapted from answer by CL
        # https://stackoverflow.com/a/15766121
        '-G', '''SELECT AVG(count)
                 FROM (SELECT count
                       FROM {0}
                       ORDER BY count
                       LIMIT 2 - (SELECT COUNT(*) FROM {0}) % 2    -- odd 1, even 2
                                  OFFSET (SELECT (COUNT(*) - 1) / 2
                                          FROM {0})
                      )'''.format(AGGREGATE_NAME)
    ]

    return queries

def median_leaf_files(_config, args, where):
    return median_leaf(_config, args, where, 'totfiles')

def median_leaf_links(_config, args, where):
    return median_leaf(_config, args, where, 'totlinks')

def median_leaf_size(_config, args, where):
    return median_leaf(_config, args, where, 'totsize')

def per_level(_config, args, where, type): # pylint: disable=redefined-builtin
    '''
    get counts of how many <type>s are in each level of the tree, by uid

    --cumulative combines the results into one set of distributions
    '''

    group_by = ['level'] + ([] if args.cumulative else ['uid'])
    order_by = None if args.cumulative else ['level {0}'.format(ORDER[args.order]),
                                             'uid {0}'.format(ORDER[args.order])]

    uid = [] if args.cumulative else ['uid']
    count = '1' if type == 'd' else '(SELECT COUNT(*) FROM entries WHERE type == \'{0}\')'.format(type)

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK)] +
                           ([] if args.cumulative else ['uid {0}'.format(SQLITE3_INT64)]) +
                           ['level {0}'.format(SQLITE3_INT64),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['NULL'] + uid + ['level()', count],
                                                       [VRSUMMARY],
                                                       where,
                                                       ['uid'],
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK)] +
                           ([] if args.cumulative else ['uid {0}'.format(SQLITE3_INT64)]) +
                           ['level {0}'.format(SQLITE3_INT64),
                            'count {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['NULL'] + uid + ['level', 'SUM(count)'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       group_by,
                                                       order_by,
                                                       None,
                                                       None)),

        '-G', build_query(([] if args.cumulative else ['uidtouser(uid)']) + ['level', 'SUM(count)'],
                          [AGGREGATE_NAME],
                          ['count != 0'],
                          group_by,
                          order_by,
                          args.num_results,
                          None),

    ]

    return queries

def files_per_level(config, args, where):
    return per_level(config, args, where, 'f')

def links_per_level(config, args, where):
    return per_level(config, args, where, 'l')

def dirs_per_level(config, args, where):
    return per_level(config, args, where, 'd')

def duplicate_names(config, args, where):
    columns = ['name', 'type', 'inode', 'mode', 'size']

    queries = [
        '-I', build_create(INTERMEDIATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK),
                            PATH_CREATE,
                            'name {0}'.format(SQLITE3_TEXT),
                            'type {0}'.format(SQLITE3_TEXT),
                            'inode {0}'.format(SQLITE3_INT64),
                            'mode {0}'.format(SQLITE3_INT64),
                            'size {0}'.format(SQLITE3_INT64)]),

        '-S', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['NULL', 'substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2)] +
                                                       columns,
                                                       [VRSUMMARY],
                                                       where,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(['NULL', 'substr(rpath(sname, sroll), {0})'.format(len(config.indexroot) + 2)] +
                                                       columns,
                                                       [VRPENTRIES],
                                                       where,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME,
                           ['id {0}'.format(SQLITE3_IPK),
                            PATH_CREATE,
                            'name {0}'.format(SQLITE3_TEXT),
                            'type {0}'.format(SQLITE3_TEXT),
                            'inode {0}'.format(SQLITE3_INT64),
                            'mode {0}'.format(SQLITE3_INT64),
                            'size {0}'.format(SQLITE3_INT64)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(['NULL', PATH] +
                                                       columns,
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', 'SELECT lhs.name, lhs.path FROM {0} AS lhs INNER JOIN (SELECT DISTINCT name, type, size FROM {0} GROUP BY name, type, size HAVING COUNT(*) > 1) AS rhs ON ((lhs.name == rhs.name) AND (lhs.type == rhs.type) AND (lhs.size == rhs.size)) ORDER BY lhs.name'.format(AGGREGATE_NAME) + ('LIMIT {0}'.format(args.num_results) if args.num_results else '')

    ]

    queries += ['-a', '1']

    return queries

def uidgid_size(config, args, uidgid, where):
    '''
    Sort files by size, grouped by uid or gid.

    Links are not included because they change size depending on
    filesystem.

    This function always recurses down the entire input path, but is
    neither recursive or cumulative because it creates partitions on
    the resulting data instead of processing each row of data
    independently or aggregating the data.
    '''

    columns = [uidgid, 'size', 'name']

    if args.num_results:
        where += ['rownum <= {0}'.format(args.num_results)]

    def partition(table):
        return build_query(columns +
                           ['row_number() OVER (PARTITION BY {0} ORDER BY size {1}) AS rownum'.format(uidgid, args.order)],
                           [table],
                           None,
                           None,
                           None,
                           None,
                           None)

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, ['{0} {1}'.format(uidgid, SQLITE3_INTEGER),
                                               'size {0}'.format(SQLITE3_INTEGER),
                                               'name {0}'.format(SQLITE3_TEXT)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query([uidgid, 'size', 'fullpath'],
                                                       ['({0})'.format(build_query([uidgid, 'size',
                                                                                    'substr(rpath(sname, sroll), {0}) || \'/\' || name AS fullpath'.format(len(config.indexroot) + 2),
                                                                                    'row_number() OVER (PARTITION BY {0} ORDER BY size {1}) AS rownum'.format(uidgid, args.order)],
                                                                                   [VRPENTRIES],
                                                                                   ['type == \'f\''],
                                                                                   None,
                                                                                   None,
                                                                                   None,
                                                                                   None))],
                                                       where,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, ['{0} {1}'.format(uidgid, SQLITE3_INTEGER),
                                            'size {0}'.format(SQLITE3_INTEGER),
                                            'name {0}'.format(SQLITE3_TEXT)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(columns,
                                                       ['({0})'.format(partition(INTERMEDIATE_NAME))],
                                                       where,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(columns,
                          ['({0})'.format(partition(AGGREGATE_NAME))],
                          where,
                          None,
                          None,
                          None,
                          None),
    ]

    return queries

def uid_size(config, args, where):
    return uidgid_size(config, args, 'uid', where)

def gid_size(config, args, where):
    return uidgid_size(config, args, 'gid', where)

def size_bins(args, base, type): # pylint: disable=redefined-builtin
    '''
    Gets histogram of sizes
    bins are [b^n, b^(n+1))

    Requires SQLite 3.35.0

    default returns bins for 1 directory
    with --recursive, groups results by path
    with --cumulative, sums all results
    '''

    EXPONENT = 'exponent'

    table = []
    field = gufi_common.SQLITE3_NULL
    if type in ['f', 'l']:
        table = [VRPENTRIES]
        field = 'size'
    elif type == 'd':
        table = [VRSUMMARY]
        field = 'totfiles'

    path_create, E_path, path = path_sql(args)

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, path_create + ['{0} {1}'.format(EXPONENT, SQLITE3_INTEGER)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(E_path + ['CASE WHEN {0} == 0 THEN -1 ELSE CAST(FLOOR(LOG({1}, {0})) AS {2}) END'.format(field, base, SQLITE3_INTEGER)],
                                                       table,
                                                       ['type == \'{0}\''.format(type)],
                                                       None, # cannot GROUP BY here because value would be aggregate
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, path_create + ['{0} {1}'.format(EXPONENT, SQLITE3_INTEGER),
                                                          'count {0}'.format(SQLITE3_INTEGER)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(path + [EXPONENT, 'COUNT({0})'.format(EXPONENT)],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       path + [EXPONENT],
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(path + ["CASE WHEN {1} == -1 THEN '[0,1)' ELSE '[' || CAST(pow({0}, {1}) AS {2}) || ',' || CAST(pow({0}, {1}+1) AS {2}) || ')' END".format(base, EXPONENT, SQLITE3_INTEGER), 'SUM(count)'],
                          [AGGREGATE_NAME],
                          None,
                          path + [EXPONENT],
                          (['path {0}'.format(ORDER[args.order])] if args.recursive else []) +
                          ['{0} {1}'.format(EXPONENT, ORDER[args.order])],
                          None,
                          None),
    ]

    if not args.recursive and not args.cumulative:
        queries += ['--max-level', '0']

    return queries

def filesize_log2_bins(_config, args, _where):
    return size_bins(args, 2, 'f')

def filesize_log1024_bins(_config, args, _where):
    return size_bins(args, 1024, 'f')

def dirfilecount_log2_bins(_config, args, _where):
    return size_bins(args, 2, 'd')

def dirfilecount_log1024_bins(_config, args, _where):
    return size_bins(args, 1024, 'd')

def size_bins_hist(args, base, type): # pylint: disable=redefined-builtin
    '''
    Gets histogram of sizes
    bins are [b^n, b^(n+1))

    Requires SQLite 3.35.0

    default returns bins for 1 directory
    with --recursive, groups results by path
    with --cumulative, sums all results
    '''

    HISTOGRAM = 'histogram'

    table = []
    field = gufi_common.SQLITE3_NULL
    if type in ['f', 'l']:
        table = [VRPENTRIES]
        field = 'size'
    elif type == 'd':
        table = [VRSUMMARY]
        field = 'totfiles'

    buckets = 0
    if base == 2:
        buckets = 60 # exabyte
    elif base == 1024:
        buckets = 6  # exabyte

    path_create, E_path, path = path_sql(args)

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, path_create + ['{0} {1}'.format(HISTOGRAM, SQLITE3_TEXT)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(E_path +
                                                       ['log_hist({0}, {1}, {2})'.format(field, base, buckets)],
                                                       table,
                                                       ['type == \'{0}\''.format(type)],
                                                       None, # cannot GROUP BY here because value would be aggregate
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, path_create + ['{0} {1}'.format(HISTOGRAM, SQLITE3_TEXT)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(path + [HISTOGRAM],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(path + ['log_hist_combine({0})'.format(HISTOGRAM)],
                          [AGGREGATE_NAME],
                          None,
                          path,
                          ['path {0}'.format(ORDER[args.order])] if args.recursive else [],
                          None,
                          None),
    ]

    if not args.recursive and not args.cumulative:
        queries += ['--max-level', '0']

    return queries

def filesize_log2_bins_hist(_config, args, _where):
    return size_bins_hist(args, 2, 'f')

def filesize_log1024_bins_hist(_config, args, _where):
    return size_bins_hist(args, 1024, 'f')

def dirfilecount_log2_bins_hist(_config, args, _where):
    return size_bins_hist(args, 2, 'd')

def dirfilecount_log1024_bins_hist(_config, args, _where):
    return size_bins_hist(args, 1024, 'd')

# do binning here
def age_bins(args, time_name, type):  # pylint: disable=redefined-builtin
    '''
    Gets histogram of ages of timestamps relative to a reference time

    Requires SQLite 3.35.0

    default returns bins for 1 directory
    with --recursive, groups results by path
    with --cumulative, sums all results
    '''

    BUCKET = 'bucket'

    table = []
    if type in ['f', 'l']:
        table = [VRPENTRIES]
    elif type == 'd':
        table = [VRSUMMARY]

    path_create, E_path, path = path_sql(args)

    # if (args.reftime - timestamp) < TIME_BUCKETS[i][0], this age
    # goes into bucket [TIME_BUCKETS[i - 1], TIME_BUCKETS[i])
    # bucket name/index, rhs max seconds, output string
    TIME_BUCKETS = [
        [0,         '[future, 0 sec ago)'],
        [1,         '[0 sec ago, 1 sec ago)'],
        [60,        '[1 sec ago, 1 minute ago)'],
        [3600,      '[1 minute ago, 1 hour ago)'],
        [86400,     '[1 hour ago, 1 day ago)'],
        [604800,    '[1 day ago, 1 week ago)'],
        [2419200,   '[1 week ago, 4 weeks ago)'],
        [31536000,  '[4 weeks ago, 1 year ago)'],
        [63072000,  '[1 year ago, 2 years ago)'],
        [157680000, '[2 year ago, 5 years ago)'],
        [315360000, '[5 year ago, 10 years ago)'],
        [630720000, '[10 year ago, 20 years ago)'],
        [630720001, '[20 year ago, older)'],
    ]

    # map to bucket
    bucket_sql = (
        'CASE ' +
        ' '.join(['WHEN ({0} - {1}) < {2} THEN {3}'.format(args.reftime, time_name, secs, bucket)
                  for bucket, (secs, _) in enumerate(TIME_BUCKETS)]) +
        ' ELSE \'years\' END'
    )

    # map bucket to output string
    out_bucket_sql = (
        'CASE {0} '.format(BUCKET) +
        ' '.join(['WHEN {0} THEN \'{1}\''.format(bucket, out)
                  for bucket, (_, out) in enumerate(TIME_BUCKETS)]) +
        ' END'
    )

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, path_create + ['{0} {1}'.format(BUCKET, SQLITE3_TEXT)]),
        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(E_path + [bucket_sql],
                                                       table,
                                                       ['type == \'{0}\''.format(type)],
                                                       None,
                                                       None,
                                                       None,
                                                       None)),
        '-K', build_create(AGGREGATE_NAME, path_create +
                           ['{0} {1}'.format(BUCKET, SQLITE3_TEXT),
                            'count {0}'.format(SQLITE3_INTEGER)]),
        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(path + [BUCKET, 'COUNT(*)'],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       path + [BUCKET],
                                                       None,
                                                       None,
                                                       None)),
        '-G', build_query(path + [out_bucket_sql, 'SUM(count)'],
                          [AGGREGATE_NAME],
                          None,
                          path + [BUCKET],
                          (['path {0}'.format(ORDER[args.order])] if args.recursive else []) +
                          ['{0} {1}'.format(BUCKET, ORDER[args.order])],
                          None,
                          None),
    ]

    if not args.recursive and not args.cumulative:
        queries += ['--max-level', '0']

    return queries

def file_age_atime(_config, args, _where):
    return age_bins(args, 'atime', 'f')

def file_age_mtime(_config, args, _where):
    return age_bins(args, 'mtime', 'f')

def file_age_ctime(_config, args, _where):
    return age_bins(args, 'ctime', 'f')

def dir_age_atime(_config, args, _where):
    return age_bins(args, 'atime', 'd')

def dir_age_mtime(_config, args, _where):
    return age_bins(args, 'mtime', 'd')

def dir_age_ctime(_config, args, _where):
    return age_bins(args, 'ctime', 'd')

# use internal histogram functionality
def age_bins_hist(args, time_name, type):  # pylint: disable=redefined-builtin
    '''
    Gets histogram of ages of timestamps relative to a reference time

    Requires SQLite 3.35.0

    default returns bins for 1 directory
    with --recursive, groups results by path
    with --cumulative, sums all results
    '''

    HISTOGRAM = 'histogram'

    table = []
    if type in ['f', 'l']:
        table = [VRPENTRIES]
    elif type == 'd':
        table = [VRSUMMARY]

    path_create, E_path, path = path_sql(args)

    queries = [
        '-I', build_create(INTERMEDIATE_NAME, path_create + ['{0} {1}'.format(HISTOGRAM, SQLITE3_TEXT)]),

        '-E', 'INSERT INTO {0} {1}'.format(INTERMEDIATE_NAME,
                                           build_query(E_path + ['time_hist({0}, {1})'.format(time_name, args.reftime)],
                                                       table,
                                                       ['type == \'{0}\''.format(type)],
                                                       None,
                                                       None,
                                                       None,
                                                       None)),

        '-K', build_create(AGGREGATE_NAME, path_create + ['{0} {1}'.format(HISTOGRAM, SQLITE3_INTEGER)]),

        '-J', 'INSERT INTO {0} {1}'.format(AGGREGATE_NAME,
                                           build_query(path + [HISTOGRAM],
                                                       [INTERMEDIATE_NAME],
                                                       None,
                                                       path + [HISTOGRAM],
                                                       None,
                                                       None,
                                                       None)),

        '-G', build_query(path + ['time_hist_combine({0})'.format(HISTOGRAM)],
                          [AGGREGATE_NAME],
                          None,
                          path,
                          ['path {0}'.format(ORDER[args.order])] if args.recursive else [],
                          None,
                          None),
    ]

    if not args.recursive and not args.cumulative:
        queries += ['--max-level', '0']

    return queries

def file_age_atime_hist(_config, args, _where):
    return age_bins_hist(args, 'atime', 'f')

def file_age_mtime_hist(_config, args, _where):
    return age_bins_hist(args, 'mtime', 'f')

def file_age_ctime_hist(_config, args, _where):
    return age_bins_hist(args, 'ctime', 'f')

def dir_age_atime_hist(_config, args, _where):
    return age_bins_hist(args, 'atime', 'd')

def dir_age_mtime_hist(_config, args, _where):
    return age_bins_hist(args, 'mtime', 'd')

def dir_age_ctime_hist(_config, args, _where):
    return age_bins_hist(args, 'ctime', 'd')

# mapping of desired statistics to functions

# normally only computes for current directory
# use --recursive to compute for every directory
RECURSIVE = [
    ['depth',                          depth],

    ['filesize',                       filesize],

    ['filecount',                      filecount],
    ['linkcount',                      linkcount],
    ['dircount',                       dircount],

    ['leaf-dirs',                      leaf_dirs],
    ['leaf-depth',                     leaf_depth],
    ['leaf-files',                     leaf_files],
    ['leaf-links',                     leaf_links],
]

# normally computes statistics by uid
# use --cumulative to combine results into single result
CUMULATIVE = [
    ['total-filesize',                 total_filesize],

    ['total-filecount',                total_filecount],
    ['total-linkcount',                total_linkcount],
    ['total-dircount',                 total_dircount],

    ['total-leaf-files',               total_leaf_files],
    ['total-leaf-links',               total_leaf_links],

    ['files-per-level',                files_per_level],
    ['links-per-level',                links_per_level],
    ['dirs-per-level',                 dirs_per_level],
]

BOTH = [
    ['extensions',                     extensions],
    ['extensions-hist',                extensions_hist],

    ['filesize-log2-bins',             filesize_log2_bins],
    ['filesize-log1024-bins',          filesize_log1024_bins],

    ['filesize-log2-bins-hist',        filesize_log2_bins_hist],
    ['filesize-log1024-bins-hist',     filesize_log1024_bins_hist],

    ['dirfilecount-log2-bins',         dirfilecount_log2_bins],
    ['dirfilecount-log1024-bins',      dirfilecount_log1024_bins],

    ['dirfilecount-log2-bins-hist',    dirfilecount_log2_bins_hist],
    ['dirfilecount-log1024-bins-hist', dirfilecount_log1024_bins_hist],

    ['file-age-atime',                 file_age_atime],
    ['file-age-mtime',                 file_age_mtime],
    ['file-age-ctime',                 file_age_ctime],

    ['dir-age-atime',                  dir_age_atime],
    ['dir-age-mtime',                  dir_age_mtime],
    ['dir-age-ctime',                  dir_age_ctime],

    ['file-age-atime-hist',            file_age_atime_hist],
    ['file-age-mtime-hist',            file_age_mtime_hist],
    ['file-age-ctime-hist',            file_age_ctime_hist],

    ['dir-age-atime-hist',             dir_age_atime_hist],
    ['dir-age-mtime-hist',             dir_age_mtime_hist],
    ['dir-age-ctime-hist',             dir_age_ctime_hist],
]

# does not use either
OTHERS = [
    ['average-leaf-files',             average_leaf_files],
    ['average-leaf-links',             average_leaf_links],
    ['average-leaf-size',              average_leaf_size], # file size only

    ['median-leaf-files',              median_leaf_files],
    ['median-leaf-links',              median_leaf_links],
    ['median-leaf-size',               median_leaf_size],  # file size only

    ['duplicate-names',                duplicate_names],

    ['uid-size',                       uid_size],
    ['gid-size',                       gid_size],
]

# argv[0] should be the command name
def run(argv, config_path):
    stats = OrderedDict(RECURSIVE + CUMULATIVE + BOTH + OTHERS)

    # find and parse the configuration file first
    config = gufi_config.Server(config_path)

    # parse the arguments
    parser = argparse.ArgumentParser('gufi_stats', description='GUFI statistics', add_help=False)

    gufi_common.add_help_version(parser)

    exclusive = parser.add_mutually_exclusive_group()
    exclusive.add_argument('-r','--recursive',
                           action='store_true',
                           help='run command recursively ({0})'.format(', '.join([key for key, _ in RECURSIVE + BOTH])))
    exclusive.add_argument('-c','--cumulative',
                           action='store_true',
                           help='return cumulative values ({0})'.format(', '.join([key for key, _ in CUMULATIVE + BOTH])))
    parser.add_argument('--order',
                        metavar='order',
                        choices=ORDER.keys(),
                        default=SQLITE3_ASC,
                        help='sort output (if applicable)')
    parser.add_argument('--num-results',
                        metavar='n',
                        type=gufi_common.get_non_negative,
                        help='first n results')
    parser.add_argument('--uid', '--user',
                        metavar='u',
                        type=gufi_common.get_uid,
                        help='restrict to user')
    parser.add_argument('--reftime',
                        default=time.time(),
                        type=gufi_common.get_non_negative,
                        help='time used to compare timestamps with')
    parser.add_argument('stat',
                        choices=stats.keys(),
                        help='statistic to get')
    parser.add_argument('path',
                        type=str,
                        nargs='?',
                        default='')

    gufi_common.add_common_flags(parser)

    args = parser.parse_args(argv[1:])

    # check args
    if args.recursive and (args.stat in [key for key, _ in CUMULATIVE]):
        sys.stderr.write('--recursive/-r has no effect on "{0}" statistic\n'.format(args.stat))
    if args.cumulative and (args.stat in [key for key, _ in RECURSIVE]):
        sys.stderr.write('--cumulative/-c has no effect on "{0}" statistic\n'.format(args.stat))
    if (args.recursive or args.cumulative) and (args.stat in [key for key, _ in OTHERS]):
        sys.stderr.write('--recursive/-r and --cumulative/-c have no effect on "{0}" statistic\n'.format(args.stat))

    # prepend the provided paths with the GUFI root path
    prefixed_path = os.path.sep.join([config.indexroot, args.path])

    if not gufi_common.in_index(prefixed_path, config.indexroot, args.path, 'Error'):
        return 1

    # create the query command
    query_cmd = [
        config.query,
        '--no-print-sql-on-err',
        '--threads', str(config.threads),
        '--output-buffer-size', str(config.outputbuffer),
        '--delim', args.delim
    ] + stats[args.stat](config, args, build_where(args))

    if args.skip:
        query_cmd += ['--skip-file', args.skip]

    if args.verbose:
        gufi_common.print_query(query_cmd + [prefixed_path])

    query = subprocess.Popen(query_cmd + [prefixed_path]) # pylint: disable=consider-using-with
    query.communicate()                                   # block until query finishes

    return query.returncode

if __name__ == '__main__':
    sys.exit(run(sys.argv, gufi_config.PATH))
