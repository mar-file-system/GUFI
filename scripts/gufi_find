#!/usr/bin/env @PYTHON_INTERPRETER@
# This file is part of GUFI, which is part of MarFS, which is released
# under the BSD license.
#
#
# Copyright (c) 2017, Los Alamos National Security (LANS), LLC
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# From Los Alamos National Security, LLC:
# LA-CC-15-039
#
# Copyright (c) 2017, Los Alamos National Security, LLC All rights reserved.
# Copyright 2017. Los Alamos National Security, LLC. This software was produced
# under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National
# Laboratory (LANL), which is operated by Los Alamos National Security, LLC for
# the U.S. Department of Energy. The U.S. Government has rights to use,
# reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR LOS
# ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR
# ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is
# modified to produce derivative works, such modified software should be
# clearly marked, so as not to confuse it with the version available from
# LANL.
#
# THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.



import argparse
import math
import os
import subprocess
import sys
import time

import gufi_common
import gufi_config

# location of this file
PATH = os.path.realpath(__file__)

SECONDS_PER_DAY = str(24 * 60 * 60) # do string conversion once

'''file size units specified in GNU find.'''
FILESIZE = {'b' : 512,
            'c' : 1,
            'w' : 2,
            'k' : 1024,
            'M' : 1048576,
            'G' : 1073741824}

def validate_args(args):
    '''Validate known arguments here'''

    # GUFI directories do not have source tree size/timestamps
    if args.type:
        if 'd' in args.type:
            if args.size or args.atime or args.mtime or args.ctime:
                raise RuntimeError('size, atime, mtime, and ctime cannot be used with -type d')

# Used to parse all numeric arguments
# From man 1 find:
#
# Numeric arguments can be specified as
#
# +n     for greater than n,
#
# -n     for less than n,
#
# n      for exactly n.
#
def numeric_arg(n):
    # pylint: disable=invalid-name
    try:
        float(n)
    except:
        # pylint: disable=raise-missing-from
        raise argparse.ArgumentTypeError("{0} is not a valid numeric argument".format(n))

    op = None
    if n[0] == '+':
        op = '>'
        n = n[1:]
    elif n[0] == '-':
        op = '<'
        n = n[1:]
    else:
        op = '=='

    return op, n

def parse_size(size):
    unit = 'b'
    if size[-1] in FILESIZE:
        unit = size[-1]
        size = size[:-1]

    comp, actual_size = numeric_arg(size)
    return comp, int(math.ceil(float(actual_size))) * FILESIZE[unit]

def need_aggregation(args):
    return bool(args.numresults or args.smallest or args.largest)

def build_where(args, table, root_uid=0, root_gid=0):
    '''Build the WHERE clause'''

    # pylint: disable=too-many-branches,unused-argument,too-many-locals,too-many-statements

    where = []

    now = time.time()

    # if not ((os.geteuid() == root_uid) or (os.getegid() == root_gid)):
    #     where += ['(uid == {0})'.format(os.getuid())]

    if args.amin is not None:
        where += ['({0} - {1}.atime) / 60 {2} {3}'.format(now, table, amin[0], amin[1]) for amin in args.amin]

    # if args.anewer is not None:

    if args.atime is not None:
        where += ['({0} - {1}.atime) / {2} {3} {4} '.format(now, table, SECONDS_PER_DAY, atime[0], atime[1]) for atime in args.atime]

    if args.cmin is not None:
        where += ['({0} - {1}.ctime) / 60 {2} {3}'.format(now, table, cmin[0], cmin[1]) for cmin in args.cmin]

    # if args.cnewer is not None:

    if args.ctime is not None:
        where += ['({0} - {1}.ctime) / {2} {3} {4} '.format(now, table, SECONDS_PER_DAY, ctime[0], ctime[1]) for ctime in args.ctime]

    if args.empty is True:
        where += ['{0}.size == 0'.format(table), '({0}.type == \'f\') OR ({0}.type == \'d\')'.format(table)]

    if args.executable is True:
        where += ['({0}.mode & 64) == 64'.format(table)] # 0100 have to use decimal or hexadecimal value because sqlite3 doesn't support octal

    if args.false is True:
        where += ['0']

    if args.gid is not None:
        where += ['{0}.gid {1} {2}'.format(table, gid[0], gid[1]) for gid in args.gid]

    if args.group is not None:
        where += ['{0}.gid == {1}'.format(table, args.group)]

    # if args.ilname is not None:

    # matches on basename
    # GLOB is case sensitive, so using REGEX
    if args.iname is not None:
        where += [' OR '.join(['{0}.name REGEXP \'(?i){1}\''.format(table, iname) for iname in args.iname])]

    if args.inum is not None:
        where += ['{0}.inode {1} {2}'.format(table, inum[0], inum[1]) for inum in args.inum]

    # Behaves in the same way as -iwholename. This option is deprecated, so please do not use it.
    # if args.ipath is not None:

    # matches on whole path
    if args.iregex is not None:
        if table == gufi_common.SUMMARY:
            where += [' OR '.join(['((path({0}.name, {0}.rollupscore)) REGEXP \'(?i){1}\')'.format(gufi_common.SUMMARY, iregex) for iregex in args.iregex])]
        elif table == gufi_common.PENTRIES:
            where += [' OR '.join(['((path({0}.name, {0}.rollupscore) || "/" || {1}.name) REGEXP \'(?i){2}\')'.format(gufi_common.SUMMARY, gufi_common.PENTRIES, iregex) for iregex in args.iregex])]

    # if args.iwholename is not None:

    if args.links is not None:
        where += ['{0}.nlink {1} {2}'.format(table, links[0], links[1]) for links in args.links]

    if args.lname is not None:
        where += ['{0}.type == \'l\''.format(table),
                  '{0}.name GLOB \'{1}\''.format(table, args.lname)]

    if args.mmin is not None:
        where += ['({0} - {1}.mtime) / 60 {2} {3}'.format(now, table, mmin[0], mmin[1]) for mmin in args.mmin]

    if args.mtime is not None:
        where += ['({0} - {1}.mtime) / {2} {3} {4}'.format(now, table, SECONDS_PER_DAY, mtime[0], mtime[1]) for mtime in args.mtime]

    # matches on basename
    if args.name is not None:
        where += [' OR '.join(['({0}.name GLOB \'{1}\')'.format(table, name) for name in args.name])]

    if args.newer is not None:
        where += ['{0}.mtime > {1}'.format(table, args.newer.st_mtime)]

    # if args.newerXY is not None:

    # if args.nouser is True:

    if args.path is not None:
        where += [' OR '.join(['(path({0}.name, {0}.rollupscore) GLOB \'{1}\')'.format(gufi_common.SUMMARY, path) for path in args.path])]

    # if args.perm is not None:

    if args.readable is True:
        where += ['({0}.mode & 256) == 256'.format(table)] # 0400 have to use decimal or hexadecimal value because sqlite3 doesn't support octal

    # matches on whole path
    if args.regex is not None:
        if table == gufi_common.SUMMARY:
            where += [' OR '.join(['((path({0}.name, {0}.rollupscore)) REGEXP \'{1}\')'.format(gufi_common.SUMMARY, regex) for regex in args.regex])]
        elif table == gufi_common.PENTRIES:
            where += [' OR '.join(['((path({0}.name, {0}.rollupscore) || "/" || {1}.name) REGEXP \'{2}\')'.format(gufi_common.SUMMARY, gufi_common.PENTRIES, regex) for regex in args.regex])]

    if args.samefile is not None:
        where += ['{0}.inode == {1}'.format(table, args.samefile.st_ino)]

    if args.size is not None:
        where += ['{0}.size {1} {2}'.format(table, size[0], size[1]) for size in args.size]

    if args.true is True:
        where += ['1']

    if args.type is not None:
        # multiple types uses OR instead of AND
        where += [' OR '.join(['({0}.type == "{1}")'.format(table, t) for t in args.type])]

    if args.uid is not None:
        where += ['{0}.uid {1} {2}'.format(table, uid[0], uid[1]) for uid in args.uid]

    # if args.used is not None:

    if args.user is not None:
        where += ['{0}.uid == {1}'.format(table, args.user)]

    # if args.wholename is not None:

    if args.writable is True:
        where += ['({0}.mode & 128) == 128'.format(table)] # 0200 have to use decimal or hexadecimal value because sqlite3 doesn't support octal

    # if args.xtype is not None:

    # if args.context is not None:

    return where

def build_group_by(_args, _table):
    '''Build the GROUP BY clause'''
    group_by = []

    return group_by

def build_order_by(args, table):
    '''Build the ORDER BY clause'''
    order_by = []

    if args.smallest:
        order_by += ['{0}.size ASC'.format(table)]

    if args.largest:
        order_by += ['{0}.size DESC'.format(table)]

    # order by name last so it doesnt break user requested ordering
    order_by += ['{0}.name ASC'.format(table)]

    return order_by

def parse_escape(fmt, i):
    ret = fmt[i]

    if ret == 'a':
        ret = '\a'
    elif ret == 'b':
        ret = '\b'
    elif ret == 'c':
        ret = ''
        i = len(fmt)
    elif ret == 'f':
        ret = '\f'
    elif ret == 'n':
        ret = '\n'
    elif ret == 'r':
        ret = '\r'
    elif ret == 't':
        ret = '\t'
    elif ret == 'v':
        ret = '\v'
    elif ret == '0':
        ret = '\0'
    elif ret == '\\':
        ret = '\\'
    elif ret.isdigit():
        ret = chr(int(fmt[i:i + 3], 8))
        i += 3
    else:
        pass

    return '"{0}"'.format(ret), i + 1

def parse_directives(table, fmt, fmt_len, i, path):
    # pylint: disable=too-many-branches,too-many-statements
    # unterminated directive prints ""; behavior is undefined in GNU find
    if i >= fmt_len:
        return '""', i

    # check for width formatting
    width = 0
    if fmt[i].isdigit() or (fmt[i] == '-') or (fmt[i] == '+') or (fmt[i] == '.'):
        j = i
        decimal_point = 0
        while fmt[j].isdigit() or (fmt[j] == '.'):
            if fmt[j] == '.':
                decimal_point += 1
            j += 1

        if decimal_point > 0:
            # let float deal with multiple decimal points
            width = float(fmt[i:j])
        else:
            width = int(fmt[i:j])

        i = j

    ret = fmt[i]

    if ret == '%':
        ret = '\'%\''
    elif ret == 'a':
        ret = 'printf("%{{0}}d", {0}.atime)'.format(table)
    # elif ret == 'A':
    elif ret == 'b':
        ret = 'printf("%{{0}}d", ({0}.blocks * {0}.blksize) / 512)'.format(table)
    elif ret == 'c':
        ret = 'printf("%{{0}}d", {0}.ctime)'.format(table)
    # elif ret == 'C':
    elif ret == 'd':
        ret = 'printf("%{{0}}u", level() + (CASE {0}.type WHEN "d" THEN 0 ELSE 1 END))'.format(table)
    elif ret == 'D':
        ret = 'printf("%{0}s", "-")'
    elif ret == 'f':
        ret = 'printf("%{{0}}s", {0}.name)'.format(table)
    # elif ret == 'F':
    elif ret == 'g':
        ret = 'gidtogroup({0}.gid, {{0}})'.format(table)
    elif ret == 'G':
        ret = 'printf("%{{0}}d", {0}.gid)'.format(table)
    elif ret == 'h':
        ret = 'printf("%{{0}}s", {0})'.format(path)
    elif ret == 'H':
        ret = 'printf("%(0}s", starting_point())'
    elif ret == 'i':
        ret = 'printf("%{{0}}d", {0}.inode)'.format(table)
    elif ret == 'k':
        ret = 'printf("%{{0}}d", ({0}.blocks * {0}.blksize) / 1024)'.format(table)
    elif ret == 'l':
        ret = 'printf("%{{0}}s", {0}.linkname)'.format(table)
    elif ret == 'm':
        ret = 'printf("%{{0}}o", {0}.mode & 511)'.format(table) # 0777 have to use decimal or hexadecimal value because sqlite3 doesn't support octal
    elif ret == 'M':
        ret = 'printf("%{{0}}s", modetotxt({0}.mode))'.format(table)
    elif ret == 'n':
        ret = 'printf("%{{0}}d", {0}.nlink)'.format(table)
    elif ret == 'p':
        ret = '{0} || (CASE {1}.type WHEN "d" THEN "" ELSE "/" || {1}.name END)'.format(path, table)
    elif ret == 'P':
        ret = 'printf("%{{0}}s", substr({0} || "/" || {1}.name, length(starting_point()) + 1))'.format(path, table)
    elif ret == 's':
        ret = 'printf("%{{0}}u", {0}.size)'.format(table)
    elif ret == 'S':
        ret = 'printf("%{{0}}d", ({0}.blksize * {0}.blocks) / {0}.size)'.format(table)
    elif ret == 't':
        ret = 'printf("%{{0}}d", {0}.mtime)'.format(table)
    # elif ret == 'T':
    elif ret == 'u':
        ret = 'uidtouser({0}.uid, {{0}})'.format(table)
    elif ret == 'U':
        ret = 'printf("%{{0}}d", {0}.uid)'.format(table)
    elif ret == 'y':
        ret = 'printf("%{{0}}s", {0}.type)'.format(table)
    # elif ret == 'Y':
    # elif ret == 'Z':
    else:
        ret = ''
        while (i < fmt_len) and (fmt[i] != '%') and (fmt[i] != '\\'):
            ret += fmt[i]
            i += 1
        ret = '"{0}"'.format(ret)
        i -= 1

    return ret.format(width), i + 1

def build_output(args, table):
    '''Build the output columns SELECT clause'''
    output = ''

    path = 'path({0}.name, {0}.rollupscore)'.format(gufi_common.SUMMARY)

    if args.printf:
        i = 0
        fmt = args.printf
        fmt_len = len(args.printf)

        cols = []
        while i < fmt_len:
            if fmt[i] == '\\':
                column, i = parse_escape(fmt, i + 1)
                cols += [column]
            elif fmt[i] == '%':
                column, i = parse_directives(table, fmt, fmt_len, i + 1, path)
                cols += [column]
            else:
                cols += ['"{0}"'.format(fmt[i])]
                i += 1
        output = ' || '.join(cols)
    else:
        output = '{0} || (CASE {1}.type WHEN "d" THEN "" ELSE "/" || {1}.name END)'.format(path, table)

    return [output]

def help(parser): # pylint: disable=redefined-builtin
    # generate list of expressions
    expr = sorted(parser.parse_args([]).__dict__.keys())

    # don't show these
    expr.remove('aggregate_name')
    expr.remove('delim')
    expr.remove('inmemory_name')
    expr.remove('skip')

    # print these separately
    gufi_specific = ['numresults', 'largest', 'smallest']
    for flag in gufi_specific:
        expr.remove(flag)

    expr = [expr[i:i + 5] for i in range(0, len(expr), 5)]

    print('Usage: gufi_find [-P] [path...] [expression]\n' +
          '\n' +
          'default path is the index root directory specified in the configuration file\n' +
          'expression may consist of:\n' +
          '\n' +
          '{}\n'.format('\n'.join(['    ' + ' '.join(row) for row in expr])) +
          '\nGUFI Specific Flags (--):\n' +
          '\n    {0}\n'.format(' '.join(gufi_specific)) +
          '\n' +
          'Report (and track progress on fixing) bugs to the GitHub Issues\n' +
          'page at https://github.com/mar-file-system/GUFI/issues\n')

def build_expression_parser():
    # parse the arguments
    parser = argparse.ArgumentParser(description='GUFI version of find', add_help=False)

    # override help to not use -h
    parser.add_argument('-help', '--help',
                        action='store_true',
                        help='Print a summary of the command-line usage of find and exit.')

    # GNU find global options
    parser.add_argument('-maxdepth',
                        metavar='levels',
                        type=gufi_common.get_non_negative,
                        help='Descend at most levels (a non-negative integer) levels of directories below the command line arguments. -maxdepth 0 means only apply the tests and actions to the command line arguments.')
    parser.add_argument('-mindepth',
                        metavar='levels',
                        type=gufi_common.get_non_negative,
                        help='Do not apply any tests or actions at levels less than levels (a non-negative integer). -mindepth 1 means process all files except the command line arguments.')
    parser.add_argument('--version', '-v',
                        action='version',
                        version='{0} @GUFI_VERSION@'.format(os.path.basename(PATH)))

    # GNU find test expressions
    parser.add_argument('-amin',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File was last accessed n minutes ago.')
    # parser.add_argument('-anewer',
    #                     metavar='file',
    #                     type=gufi_common.get_non_negative,
    #                     help='File was last accessed more recently than file was modified.')
    parser.add_argument('-atime',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File was last accessed n*24 hours ago.')
    parser.add_argument('-cmin',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File\'s status was last changed n minutes ago.')
    # parser.add_argument('-cnewer',
    #                     metavar='file',
    #                     type=gufi_common.get_non_negative,
    #                     help='File\'s status was last changed more recently than file was modified.')
    parser.add_argument('-ctime',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File\'s status was last changed n*24 hours ago.')
    parser.add_argument('-empty',
                        action='store_true',
                        help='File is empty and is either a regular file or a directory.')
    parser.add_argument('-executable',
                        action='store_true',
                        help='Matches files which are executable and directories which are searchable (in a file name resolution sense).')
    parser.add_argument('-false',
                        action='store_true',
                        help='File is false and is either a regular file or a directory.')
    # parser.add_argument('-fstype',
    #                     metavar='n',
    #                     type=str,
    #                     help='File is on a filesystem of type type.')
    parser.add_argument('-gid',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File\'s numeric group ID is n.')
    parser.add_argument('-group',
                        metavar='gname',
                        type=gufi_common.get_group,
                        help='File belongs to group gname (numeric group ID allowed).')
    # parser.add_argument('-ilname',
    #                     metavar='pattern',
    #                     type=str,
    #                     help='Like -lname, but the match is case insensitive.')
    parser.add_argument('-iname',
                        metavar='pattern',
                        type=str,
                        action='append',
                        help='Like -name, but the match is case insensitive (uses regex, not glob).')
    parser.add_argument('-inum',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File has inode number n. It is normally easier to use the -samefile test instead.')
    # parser.add_argument('-ipath',
    #                     metavar='pattern',
    #                     type=str,
    #                     help='Behaves in the same way as -iwholename. This option is deprecated, so please do not use it.')
    parser.add_argument('-iregex',
                        metavar='pattern',
                        type=str,
                        action='append',
                        help='Like -regex, but the match is case insensitive.')
    # parser.add_argument('-iwholename',
    #                     metavar='pattern',
    #                     type=str,
    #                     help='Like -wholename, but the match is case insensitive.')
    parser.add_argument('-links',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File has n links.')
    parser.add_argument('-lname',
                        metavar='pattern',
                        type=str,
                        help='File is a symbolic link whose contents match shell pattern.')
    parser.add_argument('-mmin',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File\'s data was last modified n minutes ago.')
    parser.add_argument('-mtime',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File\'s data was last modified n*24 hours ago.')
    parser.add_argument('-name',
                        metavar='pattern',
                        type=str,
                        action='append',
                        help='Base of file name (the path with the leading directories removed) matches shell pattern.')
    parser.add_argument('-newer',
                        metavar='file',
                        type=os.lstat,
                        help='File was modified more recently than file.')
    # parser.add_argument('-newerXY',
    #                     metavar='reference',
    #                     type=str,
    #                     help='Compares the timestamp of the current file with reference.')
    # parser.add_argument('-nouser',
    #                     type='store_true',
    #                     help='No user corresponds to file\'s numeric user ID.')
    parser.add_argument('-path',
                        metavar='pattern',
                        type=str,
                        action='append',
                        help='File name matches shell pattern.')
    # parser.add_argument('-perm',
    #                     metavar='mode',
    #                     type=str,
    #                     help='File\'s  permission bits')
    parser.add_argument('-readable',
                        action='store_true',
                        help='Matches files which are readable.')
    parser.add_argument('-regex',
                        metavar='pattern',
                        type=str,
                        action='append',
                        help='File name matches regular expression pattern.')
    parser.add_argument('-samefile',
                        metavar='name',
                        type=os.lstat,
                        help='File refers to the same inode as name.')
    parser.add_argument('-size',
                        metavar='n',
                        type=parse_size,
                        action='append',
                        help='')
    parser.add_argument('-true',
                        action='store_true',
                        help='Always true')
    parser.add_argument('-type',
                        metavar='c',
                        action='append',
                        type=gufi_common.get_char,
                        help='File is of type c')
    parser.add_argument('-uid',
                        metavar='n',
                        type=numeric_arg,
                        action='append',
                        help='File\'s numeric user ID is n.')
    # parser.add_argument('-used',
    #                     metavar='n',
    #                     type=numeric_arg,
    #                     action='append',
    #                     help='File was last accessed n days after its status was last changed.')
    parser.add_argument('-user',
                        metavar='uname',
                        type=gufi_common.get_user,
                        help='File is owned by user uname (numeric user ID allowed).')
    # parser.add_argument('-wholename',
    #                     metavar='pattern',
    #                     type=str,
    #                     action='append'
    #                     help='See -path. This alternative is less portable than -path.')
    parser.add_argument('-writable',
                        action='store_true',
                        help='Matches files which are writable.')
    # parser.add_argument('-xtype',
    #                     metavar='c',
    #                     type=gufi_common.get_char,
    #                     help='The same as -type unless the file is a symbolic link.')
    # parser.add_argument('-context',
    #                     metavar='pattern',
    #                     type=str,
    #                     help='(SELinux only) Security context of the file matches glob pattern.')

    # GNU find actions
    parser.add_argument('-fprint',
                        metavar='file',
                        type=str,
                        help='Output file prefix (Creates file <output>.tid)')
    parser.add_argument('-printf',
                        metavar='format',
                        type=str,
                        help='print format on the standard output, similar to GNU find')

    # GUFI specific arguments
    parser.add_argument('--numresults',
                        metavar='n',
                        type=gufi_common.get_non_negative,
                        help='first n results')
    parser.add_argument('--smallest',
                        action='store_true',
                        help='smallest results')
    parser.add_argument('--largest',
                        action='store_true',
                        help='largest results')

    gufi_common.add_common_flags(parser)

    return parser

# argv[0] should be the command name
def run(argv, config_path):
    # pylint: disable=too-many-locals,too-many-branches,too-many-statements
    # find and parse the configuration file first
    config = gufi_config.Server(config_path)

    expression_parser = build_expression_parser()

    at_expressions = False # whether or not the command line arguments started with expressions

    # parse 'real' options
    real = {
        # 'H': False,
        # 'L': False,
        'P': True,
        # 'D': False, # don't even handle here
        # 'O': False, # don't even handle here
    }

    i = 1
    while (i < len(argv)) and (argv[i][0] == '-'):
        # must be separate arguments
        # if any flags are not H, L, or P, immediately treat
        # the rest of the flags as expression flags
        if argv[i][1:] not in ['H', 'L', 'P']:
            at_expressions = True
            break

        if argv[i][1:] in ['H', 'L']:
            sys.stderr.write('Found flag {0}. Ignoring.\n'.format(argv[i][1:]))
        else:
            real[argv[i][1:]] = True

        i += 1

    if at_expressions and (sys.argv[i][0] != '-'):
        raise RuntimeError('gufi_find: paths must preceed expression: {0}'.format(sys.argv[i - 1]))

    # parse paths
    paths = []
    while (i < len(argv)) and (argv[i][0] != '-'):
        paths += [argv[i]]
        i += 1
    if len(paths) == 0:
        paths = ['']

    # prepend the provided paths with the GUFI root path
    paths = [os.path.normpath(os.path.sep.join([config.indexroot(), path])) for path in paths]

    # parse expressions without the 'real' and path arguments
    args, unknown = expression_parser.parse_known_args(argv[i:])

    if args.help:
        help(expression_parser)
        return 0

    if len(unknown) > 0:
        raise RuntimeError('gufi_find: unknown predicate `{0}\''.format(unknown[0]))

    validate_args(args)

    # create the query command
    query_cmd = [config.executable(),
                 '-n', str(config.threads()),
                 '-B', str(config.outputbuffer()),
                 '-a',
                 '-d', ' ']

    # pylint: disable=invalid-name
    if need_aggregation(args):
        columns = ['type', 'inode', 'mode', 'nlink', 'uid', 'gid',
                   'size', 'blksize', 'blocks', 'atime', 'mtime',
                   'ctime', 'linkname', 'xattr_names']

        out_columns = ['id INTEGER PRIMARY KEY',
                       'name TEXT',        'type TEXT',
                       'inode INT64',      'mode INT64',
                       'nlink INT64',      'uid INT64',
                       'gid INT64',        'size INT64',
                       'blksize INT64',    'blocks INT64',
                       'atime INT64',      'mtime INT64',
                       'ctime INT64',      'linkname TEXT',
                       'xattr_names TEXT', 'output TEXT']

        I = 'CREATE TABLE {0} ({1})'.format(
            args.inmemory_name,
            ', '.join(out_columns))

        S = 'INSERT INTO {0} {1}'.format(
            args.inmemory_name,
            gufi_common.build_query(['NULL',
                                     'path({0}.name, {0}.rollupscore)'.format(gufi_common.SUMMARY)] +
                                    ['{0}.{1}'.format(gufi_common.SUMMARY, column) for column in columns] +
                                    build_output(args, gufi_common.SUMMARY),
                                    [gufi_common.SUMMARY],
                                    build_where(args, gufi_common.SUMMARY),
                                    build_group_by(args, gufi_common.SUMMARY),
                                    build_order_by(args, gufi_common.SUMMARY),
                                    args.numresults))

        E = 'INSERT INTO {0} {1}'.format(
            args.inmemory_name,
            gufi_common.build_query(['NULL',
                                     'path({0}.name, {0}.rollupscore) || "/" || {1}.name'.format(gufi_common.SUMMARY, gufi_common.PENTRIES)] +
                                    ['{0}.{1}'.format(gufi_common.PENTRIES, column) for column in columns] +
                                    build_output(args, gufi_common.PENTRIES),
                                    [gufi_common.SUMMARY, gufi_common.PENTRIES],
                                    build_where(args, gufi_common.PENTRIES) +
                                    ['{0}.inode == {1}.pinode'.format(gufi_common.SUMMARY, gufi_common.PENTRIES)],
                                    build_group_by(args, gufi_common.PENTRIES),
                                    build_order_by(args, gufi_common.PENTRIES),
                                    args.numresults))

        K = 'CREATE TABLE {0} ({1})'.format(
            args.aggregate_name,
            ', '.join(out_columns))

        J = "INSERT INTO {0} {1}".format(
            args.aggregate_name,
            gufi_common.build_query(['NULL', 'name'] + columns + ['output'],
                                    [args.inmemory_name],
                                    build_where(args, args.inmemory_name),
                                    build_group_by(args, args.inmemory_name),
                                    build_order_by(args, args.inmemory_name),
                                    args.numresults))

        G = gufi_common.build_query(['output' if args.printf else 'name'],
                                    [args.aggregate_name],
                                    build_where(args, args.aggregate_name),
                                    build_group_by(args, args.aggregate_name),
                                    build_order_by(args, args.aggregate_name),
                                    args.numresults)

        query_cmd += ['-I', I,
                      '-S', S,
                      '-E', E,
                      '-J', J,
                      '-K', K,
                      '-G', G]
    else:
        S = gufi_common.build_query(build_output(args, gufi_common.SUMMARY),
                                    [gufi_common.SUMMARY],
                                    build_where(args, gufi_common.SUMMARY),
                                    build_group_by(args, gufi_common.SUMMARY),
                                    build_order_by(args, gufi_common.SUMMARY),
                                    args.numresults)

        E = gufi_common.build_query(build_output(args, gufi_common.PENTRIES),
                                    [gufi_common.SUMMARY, gufi_common.PENTRIES],
                                    build_where(args, gufi_common.PENTRIES) +
                                    ['{0}.inode == {1}.pinode'.format(gufi_common.SUMMARY, gufi_common.PENTRIES)],
                                    build_group_by(args, gufi_common.PENTRIES),
                                    build_order_by(args, gufi_common.PENTRIES),
                                    args.numresults)
        query_cmd += ['-S', S,
                      '-E', E]

    if args.maxdepth is not None:
        query_cmd += ['-z', str(args.maxdepth)]

    if args.mindepth is not None:
        query_cmd += ['-y', str(args.mindepth)]

    if args.fprint:
        query_cmd += ['-o', args.fprint]

    if args.skip:
        query_cmd += ['-k', args.skip]

    query = subprocess.Popen(query_cmd + paths) # pylint: disable=consider-using-with
    query.communicate()                         # block until query finishes

    return query.returncode

if __name__ == '__main__':
    sys.exit(run(sys.argv, gufi_config.DEFAULT_PATH))
