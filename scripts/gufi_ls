#!/usr/bin/env @PYTHON_INTERPRETER@
# This file is part of GUFI, which is part of MarFS, which is released
# under the BSD license.
#
#
# Copyright (c) 2017, Los Alamos National Security (LANS), LLC
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# From Los Alamos National Security, LLC:
# LA-CC-15-039
#
# Copyright (c) 2017, Los Alamos National Security, LLC All rights reserved.
# Copyright 2017. Los Alamos National Security, LLC. This software was produced
# under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National
# Laboratory (LANL), which is operated by Los Alamos National Security, LLC for
# the U.S. Department of Energy. The U.S. Government has rights to use,
# reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR LOS
# ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR
# ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is
# modified to produce derivative works, such modified software should be
# clearly marked, so as not to confuse it with the version available from
# LANL.

# THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.



import argparse
import os
import subprocess
import sys

import gufi_common
import gufi_config

#        1024  1000  1024
SIZES = ['K',  'KB', 'KiB',
         'M',  'MB', 'MiB',
         'G',  'GB', 'GiB',
         'T',  'TB', 'TiB',
         'P',  'PB', 'PiB',
         'E',  'EB', 'EiB',
         'Z',  'ZB', 'ZiB',
         'Y',  'YB', 'YiB']

def select_size(args, name):
    # in GNU ls, order of arguments determines which one has precedence
    # here, --human-readable has precedence
    if args.human_readable:
        column = 'human_readable_size({{0}}, {0})'.format(args.size_width)
    elif args.blocksize:
        column = 'blocksize({{0}}, "{0}", {1})'.format(args.blocksize, args.size_width)
    else:
        column = 'printf("%{0}d", {{0}})'.format(args.size_width)

    return [column.format(name)]

TIME_STYLES = {
    'full-iso' : '%F %T %z',
    'long-iso' : '%F %T',
    'iso'      : '%m-%d %R',
    'locale'   : '%b  %e %H:%M',
}

def select_time(style, name):
    if not style:
        style = 'locale'

    try:
        column = 'strftime("{0}", {{0}})'.format(TIME_STYLES[style])
    except:
        # pylint: disable=raise-missing-from
        raise ValueError('gufi_ls: invalid argument \'{0}\' for \'time style\''.format(style))

    return [column.format(name)]

def build_select(args):
    '''Build the SELECT portion of the query on the initial scan of entries'''
    select = []

    # ordering of concatenation matters

    if args.inode:
        select += ['inode']

    if args.size:
        select += ['blocks']

    if args.recursive:
        display_name = 'fullpath'
    else:
        display_name = 'name'

    if args.long_listing:
        select += ['modetotxt(mode)',
                   'printf("%{0}d", nlink)'.format(args.nlink_width),
                   'uidtouser(uid, {0})'.format(args.user_width)]
        if not args.no_group:
            select += ['gidtogroup(gid, {0})'.format(args.group_width)]

        # in GNU ls, order of arguments determines which one has precedence
        # here, --human-readable has precedence
        select += select_size(args, 'size') + select_time(args.time_style, 'mtime') + [
            '''(
                CASE
                    WHEN (type == "l") THEN
                        ({0} || " -> " || linkname)
                    ELSE
                        {0}
                    END
               ) AS display_name'''.format(display_name)
        ]
    else:
        # at minimum, print the file name
        select += [display_name + ' AS display_name']

    return select

def build_where(args, table, name=None):
    '''Build the WHERE portion of the query'''
    where = []

    if not table:
        table = ''

    if table != '':
        table += '.'

    if name:
        where = ['{0}name REGEXP "^{1}$"'.format(table, name)]
    else:
        # pylint: disable=anomalous-backslash-in-string

        # -a: if show all, override -A
        if args.all:
            pass
        else:
            # -A: ignore . and ..
            if args.almost_all:
                where += ['{0}name <> "." AND {0}name <> ".."'.format(table)]

            # everything that's not hidden
            else:
                where += ['{0}name REGEXP "^(?![\.]).*$"'.format(table)]

        # -B: ignore files that end with ~
        if args.ignore_backups is True:
            where += ['{0}name REGEXP "^.*(?<![\~])$"'.format(table)]

    return where

def build_order_by(args):
    '''Build the ORDER BY portion of the query.'''
    order_by = []

    if args.sort_largest:
        order_by += ['size {0}'.format('ASC' if args.reverse else 'DESC')]

    if args.mtime:
        order_by += ['mtime {0}'.format('ASC' if args.reverse else 'DESC')]

    if len(order_by) == 0:
        order_by += ['display_name COLLATE NOCASE {0}'.format('DESC' if args.reverse else 'ASC')]

    if args.no_sort:
        order_by = []

    return order_by

# argv[0] should be the command name
def run(argv, config_path):
    # pylint: disable=too-many-statements,too-many-locals,invalid-name

    # find and parse the configuration file first
    config = gufi_config.Server(config_path)

    class FullTimeAction(argparse.Action): # pylint: disable=too-few-public-methods
        def __init__(self, option_strings, dest, nargs=None, **kwargs):
            # pylint: disable=super-with-arguments
            super(FullTimeAction, self).__init__(option_strings, dest, 0, **kwargs)

        def __call__(self, parser, namespace, values, option_string=None):
            # --full-time
            #        like -l --time-style=full-iso
            setattr(namespace, 'long_listing', True)
            setattr(namespace, 'time_style', 'full-iso')

    # parse the arguments
    parser = argparse.ArgumentParser(description='GUFI version of ls', add_help=False)
    # override help to not use -h
    parser.add_argument('--help',
                        action='help',
                        help='show this help message and exit')
    parser.add_argument('--version', '-v',
                        action='version',
                        version=os.path.basename(os.path.realpath(__file__)) + ' @GUFI_VERSION@')
    parser.add_argument('-a', '--all',
                        action='store_true',
                        help='do not ignore entries starting with .')
    parser.add_argument('-A', '--almost-all',
                        action='store_true',
                        help='do not list implied . and ..')
    parser.add_argument('--block-size',
                        help='with -l, scale sizes by SIZE when printing them')
    parser.add_argument('-B', '--ignore-backups',
                        action='store_true',
                        help='do not list implied entries ending with ~')
    parser.add_argument('--full-time',
                        action=FullTimeAction,
                        help='like -l --time-style=full-iso')
    parser.add_argument('-G', '--no-group',
                        action='store_true',
                        help='in a long listing, don\'t print group names')
    parser.add_argument('-h', '--human-readable',
                        action='store_true',
                        help='with -l and -s, print sizes like 1K 234M 2G etc.')
    parser.add_argument('-i', '--inode',
                        action='store_true',
                        help='print the index number of each file')
    parser.add_argument('-l',
                        dest='long_listing',
                        action='store_true',
                        help='use a long listing format')
    parser.add_argument('-r', '--reverse',
                        action='store_true',
                        help='reverse order while sorting')
    parser.add_argument('-R', '--recursive',
                        action='store_true',
                        help='list subdirectories recursively')
    parser.add_argument('-s', '--size',
                        action='store_true',
                        help='print the allocated size of each file, in blocks')
    parser.add_argument('-S',
                        dest='sort_largest',
                        action='store_true',
                        help='sort by file size, largest first')
    parser.add_argument('--time-style',
                        metavar='TIME_STYLE',
                        help='time/date format with -l')
    parser.add_argument('-t',
                        dest='mtime',
                        action='store_true',
                        help='sort by modification time, newest first')
    parser.add_argument('-U',
                        dest='no_sort',
                        action='store_true',
                        help='do not sort; list entries in directory order')

    parser.add_argument('paths',
                        type=str,
                        action='append',
                        nargs='*')

    # GUFI specific arguments
    parser.add_argument('--nlink-width',
                        metavar='chars',
                        type=gufi_common.get_non_negative,
                        default=2,
                        help='Width of nlink column')
    parser.add_argument('--size-width',
                        metavar='chars',
                        type=gufi_common.get_non_negative,
                        default=10,
                        help='Width of size column')
    parser.add_argument('--user-width',
                        metavar='chars',
                        type=gufi_common.get_non_negative,
                        default=5,
                        help='Width of user column')
    parser.add_argument('--group-width',
                        metavar='chars',
                        type=gufi_common.get_non_negative,
                        default=5,
                        help='Width of group column')

    gufi_common.add_common_flags(parser)

    args = parser.parse_args(argv[1:])

    # return code
    rc = 0

    # at least 1 argument
    if len(args.paths[0]) == 0:
        args.paths = [['']]

    for path in args.paths[0]:
        # prepend the provided paths with the GUFI index root
        fullpath = os.path.normpath(os.path.sep.join([config.indexroot(), path]))

        match_name = None

        if not os.path.isdir(fullpath):
            # split the path up for matching
            fullpath, match_name = os.path.split(fullpath)

        # create the base command
        query_cmd = [config.executable(),
                     '-n', str(config.threads())]

        if not args.recursive:
            query_cmd += ['-y', '0',
                          '-z', '2']

        columns = ['fullpath', 'name', 'type', 'inode', 'nlink',
                   'size', 'mode', 'uid', 'gid', 'blksize', 'blocks',
                   'mtime', 'atime', 'ctime', 'linkname',
                   'xattr_names', 'pinode']

        create_table_cols = ', '.join(
            [
                '{0} {1}'.format(column, type)
                for column, type in zip(columns, # pylint: disable=redefined-builtin
                                        ['TEXT', 'TEXT', 'TEXT', 'INT64', 'INT64',
                                         'INT64', 'INT64', 'INT64', 'INT64', 'INT64', 'INT64',
                                         'INT64', 'INT64', 'INT64', 'TEXT',
                                         'TEXT', 'INT64'])
            ]
        )

        I = 'CREATE TABLE {0} ({1});'.format(args.inmemory_name, create_table_cols)

        S_where = build_where(args, None, match_name)
        E_where = build_where(args, gufi_common.PENTRIES, match_name) + ['{0}.inode == {1}.pinode'.format(gufi_common.SUMMARY, gufi_common.PENTRIES)]

        if args.recursive:
            S_where += ['level() > 0']
        else:
            S_where += [gufi_common.ROLLUP_SUMMARY_WHERE]
            # only get the pentries that were originally in this directory
            E_where += ['{0}.isroot == 1'.format(gufi_common.SUMMARY), 'level() == 0']

        S = 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                         gufi_common.build_query(['path({0}.name, {0}.rollupscore)'.format(gufi_common.SUMMARY), 'basename(name)'] + columns[2:],
                                                                 [gufi_common.SUMMARY],
                                                                 S_where,
                                                                 None,
                                                                 None,
                                                                 None))

        E = 'INSERT INTO {0} {1}'.format(args.inmemory_name,
                                         gufi_common.build_query(['path({0}.name, {0}.rollupscore) || "/" || {1}.name'.format(gufi_common.SUMMARY, gufi_common.PENTRIES)] +
                                                                 ['{0}.{1}'.format(gufi_common.PENTRIES, column) for column in ['name'] + columns[2:]],
                                                                 [gufi_common.SUMMARY, gufi_common.PENTRIES],
                                                                 E_where,
                                                                 None,
                                                                 None,
                                                                 None))

        J = 'INSERT INTO {0} {1}'.format(args.aggregate_name,
                                         gufi_common.build_query(['*'],
                                                                 [args.inmemory_name],
                                                                 None,
                                                                 None,
                                                                 None,
                                                                 None))

        K = 'CREATE TABLE {0} ({1});'.format(args.aggregate_name, create_table_cols)

        G = gufi_common.build_query(build_select(args),
                                    [args.aggregate_name],
                                    None,
                                    None,
                                    build_order_by(args),
                                    None)

        query_cmd += ['-I', I,
                      '-S', S,
                      '-E', E,
                      '-J', J,
                      '-K', K,
                      '-G', G,
                      '-a',
                      '-B', str(config.outputbuffer())]

        if args.delim:
            query_cmd += ['-d', args.delim]

        if args.skip:
            query_cmd += ['-k', args.skip]

        query = subprocess.Popen(query_cmd + [fullpath]) # pylint: disable=consider-using-with
        query.communicate()                              # block until query finishes

        if query.returncode != 0:
            rc = 2

    return rc

if __name__ == '__main__':
    sys.exit(run(sys.argv, gufi_config.DEFAULT_PATH))
